/* Kola License
 * ------------
 * This file is part of the Kola language specification.
 *
 * Copyright 2006,2012 Etienne M. Gagnon <egagnon@j-meg.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is based on the Java 1.7 specificcation for SableCC by Etienne M. Gagnon.
 */


/* 
 * Original License
 * ----------------
 * Copyright 2006,2012 Etienne M. Gagnon <egagnon@j-meg.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package se.sics.kola;


Helpers

  unicode_input_character = [0..0xffff];
  ht  = 0x0009;
  lf  = 0x000a;
  ff  = 0x000c;
  cr  = 0x000d;
  sp  = ' ';

  not_star = [unicode_input_character - '*'];
  not_star_not_slash = [unicode_input_character - ['*' + '/']];

  // Note: Helpers related to java_letter and java_letter_or_digit
  // have not been verified to exactly match the specification.

  unicode_letter =
    [0x0041..0x005a] | [0x0061..0x007a] | [0x00aa..0x00aa] | [0x00b5..0x00b5] |
    [0x00ba..0x00ba] | [0x00c0..0x00d6] | [0x00d8..0x00f6] | [0x00f8..0x01f5] |
    [0x01fa..0x0217] | [0x0250..0x02a8] | [0x02b0..0x02b8] | [0x02bb..0x02c1] |
    [0x02d0..0x02d1] | [0x02e0..0x02e4] | [0x037a..0x037a] | [0x0386..0x0386] |
    [0x0388..0x038a] | [0x038c..0x038c] | [0x038e..0x03a1] | [0x03a3..0x03ce] |
    [0x03d0..0x03d6] | [0x03da..0x03da] | [0x03dc..0x03dc] | [0x03de..0x03de] |
    [0x03e0..0x03e0] | [0x03e2..0x03f3] | [0x0401..0x040c] | [0x040e..0x044f] |
    [0x0451..0x045c] | [0x045e..0x0481] | [0x0490..0x04c4] | [0x04c7..0x04c8] |
    [0x04cb..0x04cc] | [0x04d0..0x04eb] | [0x04ee..0x04f5] | [0x04f8..0x04f9] |
    [0x0531..0x0556] | [0x0559..0x0559] | [0x0561..0x0587] | [0x05d0..0x05ea] |
    [0x05f0..0x05f2] | [0x0621..0x063a] | [0x0640..0x064a] | [0x0671..0x06b7] |
    [0x06ba..0x06be] | [0x06c0..0x06ce] | [0x06d0..0x06d3] | [0x06d5..0x06d5] |
    [0x06e5..0x06e6] | [0x0905..0x0939] | [0x093d..0x093d] | [0x0958..0x0961] |
    [0x0985..0x098c] | [0x098f..0x0990] | [0x0993..0x09a8] | [0x09aa..0x09b0] |
    [0x09b2..0x09b2] | [0x09b6..0x09b9] | [0x09dc..0x09dd] | [0x09df..0x09e1] |
    [0x09f0..0x09f1] | [0x0a05..0x0a0a] | [0x0a0f..0x0a10] | [0x0a13..0x0a28] |
    [0x0a2a..0x0a30] | [0x0a32..0x0a33] | [0x0a35..0x0a36] | [0x0a38..0x0a39] |
    [0x0a59..0x0a5c] | [0x0a5e..0x0a5e] | [0x0a72..0x0a74] | [0x0a85..0x0a8b] |
    [0x0a8d..0x0a8d] | [0x0a8f..0x0a91] | [0x0a93..0x0aa8] | [0x0aaa..0x0ab0] |
    [0x0ab2..0x0ab3] | [0x0ab5..0x0ab9] | [0x0abd..0x0abd] | [0x0ae0..0x0ae0] |
    [0x0b05..0x0b0c] | [0x0b0f..0x0b10] | [0x0b13..0x0b28] | [0x0b2a..0x0b30] |
    [0x0b32..0x0b33] | [0x0b36..0x0b39] | [0x0b3d..0x0b3d] | [0x0b5c..0x0b5d] |
    [0x0b5f..0x0b61] | [0x0b85..0x0b8a] | [0x0b8e..0x0b90] | [0x0b92..0x0b95] |
    [0x0b99..0x0b9a] | [0x0b9c..0x0b9c] | [0x0b9e..0x0b9f] | [0x0ba3..0x0ba4] |
    [0x0ba8..0x0baa] | [0x0bae..0x0bb5] | [0x0bb7..0x0bb9] | [0x0c05..0x0c0c] |
    [0x0c0e..0x0c10] | [0x0c12..0x0c28] | [0x0c2a..0x0c33] | [0x0c35..0x0c39] |
    [0x0c60..0x0c61] | [0x0c85..0x0c8c] | [0x0c8e..0x0c90] | [0x0c92..0x0ca8] |
    [0x0caa..0x0cb3] | [0x0cb5..0x0cb9] | [0x0cde..0x0cde] | [0x0ce0..0x0ce1] |
    [0x0d05..0x0d0c] | [0x0d0e..0x0d10] | [0x0d12..0x0d28] | [0x0d2a..0x0d39] |
    [0x0d60..0x0d61] | [0x0e01..0x0e2e] | [0x0e30..0x0e30] | [0x0e32..0x0e33] |
    [0x0e40..0x0e46] | [0x0e81..0x0e82] | [0x0e84..0x0e84] | [0x0e87..0x0e88] |
    [0x0e8a..0x0e8a] | [0x0e8d..0x0e8d] | [0x0e94..0x0e97] | [0x0e99..0x0e9f] |
    [0x0ea1..0x0ea3] | [0x0ea5..0x0ea5] | [0x0ea7..0x0ea7] | [0x0eaa..0x0eab] |
    [0x0ead..0x0eae] | [0x0eb0..0x0eb0] | [0x0eb2..0x0eb3] | [0x0ebd..0x0ebd] |
    [0x0ec0..0x0ec4] | [0x0ec6..0x0ec6] | [0x0edc..0x0edd] | [0x0f40..0x0f47] |
    [0x0f49..0x0f69] | [0x10a0..0x10c5] | [0x10d0..0x10f6] | [0x1100..0x1159] |
    [0x115f..0x11a2] | [0x11a8..0x11f9] | [0x1e00..0x1e9b] | [0x1ea0..0x1ef9] |
    [0x1f00..0x1f15] | [0x1f18..0x1f1d] | [0x1f20..0x1f45] | [0x1f48..0x1f4d] |
    [0x1f50..0x1f57] | [0x1f59..0x1f59] | [0x1f5b..0x1f5b] | [0x1f5d..0x1f5d] |
    [0x1f5f..0x1f7d] | [0x1f80..0x1fb4] | [0x1fb6..0x1fbc] | [0x1fbe..0x1fbe] |
    [0x1fc2..0x1fc4] | [0x1fc6..0x1fcc] | [0x1fd0..0x1fd3] | [0x1fd6..0x1fdb] |
    [0x1fe0..0x1fec] | [0x1ff2..0x1ff4] | [0x1ff6..0x1ffc] | [0x207f..0x207f] |
    [0x2102..0x2102] | [0x2107..0x2107] | [0x210a..0x2113] | [0x2115..0x2115] |
    [0x2118..0x211d] | [0x2124..0x2124] | [0x2126..0x2126] | [0x2128..0x2128] |
    [0x212a..0x2131] | [0x2133..0x2138] | [0x3005..0x3005] | [0x3031..0x3035] |
    [0x3041..0x3094] | [0x309b..0x309e] | [0x30a1..0x30fa] | [0x30fc..0x30fe] |
    [0x3105..0x312c] | [0x3131..0x318e] | [0x4e00..0x9fa5] | [0xac00..0xd7a3] |
    [0xf900..0xfa2d] | [0xfb00..0xfb06] | [0xfb13..0xfb17] | [0xfb1f..0xfb28] |
    [0xfb2a..0xfb36] | [0xfb38..0xfb3c] | [0xfb3e..0xfb3e] | [0xfb40..0xfb41] |
    [0xfb43..0xfb44] | [0xfb46..0xfbb1] | [0xfbd3..0xfd3d] | [0xfd50..0xfd8f] |
    [0xfd92..0xfdc7] | [0xfdf0..0xfdfb] | [0xfe70..0xfe72] | [0xfe74..0xfe74] |
    [0xfe76..0xfefc] | [0xff21..0xff3a] | [0xff41..0xff5a] | [0xff66..0xffbe] |
    [0xffc2..0xffc7] | [0xffca..0xffcf] | [0xffd2..0xffd7] | [0xffda..0xffdc];

  unicode_digit =
    [0x0030..0x0039] | [0x0660..0x0669] | [0x06f0..0x06f9] | [0x0966..0x096f] |
    [0x09e6..0x09ef] | [0x0a66..0x0a6f] | [0x0ae6..0x0aef] | [0x0b66..0x0b6f] |
    [0x0be7..0x0bef] | [0x0c66..0x0c6f] | [0x0ce6..0x0cef] | [0x0d66..0x0d6f] |
    [0x0e50..0x0e59] | [0x0ed0..0x0ed9] | [0x0f20..0x0f29] | [0xff10..0xff19];

  java_letter = unicode_letter | '$' | '_';
  java_letter_or_digit = unicode_letter | unicode_digit | '$' | '_';

  // 3.4

  line_terminator = lf | cr | cr lf;
  input_character = [unicode_input_character - [cr + lf]];

  // 3.6

  white_space = (sp | ht | ff | line_terminator);

  // 3.7

  traditional_comment = '/*' not_star* ('*' (not_star_not_slash not_star*)?)* '*/';

  // The line terminator is made optional to accept comments on the last line
  // (followed by eof).

  end_of_line_comment = '//' input_character* line_terminator?;

  // 3.10

  underscores = '_'+;

  binary_digit = '0' | '1';
  binary_digit_or_underscore = binary_digit | '_';
  binary_digits_and_underscores = binary_digit_or_underscore+;
  binary_digits = binary_digit | binary_digit binary_digits_and_underscores? binary_digit;
  binary_numeral = '0' ('b' | 'B') binary_digits;

  octal_digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7';
  octal_digit_or_underscore = octal_digit | '_';
  octal_digits_and_underscores = octal_digit_or_underscore+;
  octal_digits = octal_digit | octal_digit octal_digits_and_underscores? octal_digit;
  octal_numeral = '0' octal_digits | '0' underscores octal_digits;

  hex_digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';
  hex_digit_or_underscore = hex_digit | '_';
  hex_digits_and_underscores = hex_digit_or_underscore+;
  hex_digits = hex_digit | hex_digit hex_digits_and_underscores? hex_digit;
  hex_numeral = '0' ('x' | 'X') hex_digits;

  non_zero_digit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
  digit = '0' | non_zero_digit;
  digit_or_underscore = digit | '_';
  digits_and_underscores = digit_or_underscore+;
  digits = digit | digit digits_and_underscores? digit;
  decimal_numeral = '0' | non_zero_digit digits? | non_zero_digit underscores digits;

  integer_type_suffix = 'l' | 'L';

  decimal_integer_literal = decimal_numeral integer_type_suffix?;
  hex_integer_literal = hex_numeral integer_type_suffix?;
  octal_integer_literal = octal_numeral integer_type_suffix?;
  binary_integer_literal = binary_numeral integer_type_suffix?;

  float_type_suffix = 'f' | 'F' | 'd' | 'D';
  sign = '-' | '+';
  signed_integer = sign? digits;
  exponent_indicator = 'e' | 'E';
  exponent_part = exponent_indicator signed_integer;
  decimal_floating_point_literal =
    digits '.' digits? exponent_part? float_type_suffix? |
    '.' digits exponent_part? float_type_suffix? |
    digits exponent_part float_type_suffix? |
    digits exponent_part? float_type_suffix;

  binary_exponent_indicator = 'p' | 'P';
  binary_exponent = binary_exponent_indicator signed_integer;
  hex_significand = hex_numeral | hex_numeral '.' | '0' ('x' | 'X') hex_digits? '.' hex_digits;
  hexadecimal_floating_point_literal = hex_significand binary_exponent float_type_suffix?;

  single_character = [input_character - [''' + '\']];

  zero_to_three = '0' | '1' | '2' | '3';
  octal_escape = '\' octal_digit | '\' octal_digit octal_digit | '\' zero_to_three octal_digit octal_digit;
  escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\' | octal_escape;

  string_character = [input_character - ['"' + '\']] | escape_sequence;

Tokens

  // 3.7

  comment = traditional_comment | end_of_line_comment;

  // 3.9

  abstract_keyword = 'abstract';
  assert_keyword = 'assert';
  boolean_keyword = 'boolean';
  break_keyword = 'break';
  byte_keyword = 'byte';
  case_keyword = 'case';
  catch_keyword = 'catch';
  char_keyword = 'char';
  class_keyword = 'class';
  const_keyword = 'const';

  continue_keyword = 'continue';
  default_keyword = 'default';
  do_keyword = 'do';
  double_keyword = 'double';
  else_keyword = 'else';
  enum_keyword = 'enum';
  extends_keyword = 'extends';
  final_keyword = 'final';
  finally_keyword = 'finally';
  float_keyword = 'float';

  for_keyword = 'for';
  if_keyword = 'if';
  goto_keyword = 'goto';
  implements_keyword = 'implements';
  import_keyword = 'import';
  instanceof_keyword = 'instanceof';
  int_keyword = 'int';
  interface_keyword = 'interface';
  long_keyword = 'long';
  native_keyword = 'native';

  new_keyword = 'new';
  package_keyword = 'package';
  private_keyword = 'private';
  protected_keyword = 'protected';
  public_keyword = 'public';
  return_keyword = 'return';
  short_keyword = 'short';
  static_keyword = 'static';
  strictfp_keyword = 'strictfp';
  super_keyword = 'super';

  switch_keyword = 'switch';
  synchronized_keyword = 'synchronized';
  this_keyword = 'this';
  throw_keyword = 'throw';
  throws_keyword = 'throws';
  transient_keyword = 'transient';
  try_keyword = 'try';
  void_keyword = 'void';
  volatile_keyword = 'volatile';
  while_keyword = 'while';

  // Kompics
  definition_keyword = 'definition';
  handler_keyword = 'handler';
  handle_keyword = 'handle';
  port_keyword = 'port';
  component_keyword = 'component';
  subscribe_keyword = 'subscribe';
  unsubscribe_keyword = 'unsubscribe';
  connect_keyword = 'connect';
  disconnect_keyword = 'disconnect';
  init_keyword = 'init';
  trigger_keyword = 'trigger';
  requires_keyword = 'requires';
  provides_keyword = 'provides';
  indication_keyword = 'indication';
  request_keyword = 'request';
  event_keyword = 'event';
  r_arrow = '->';


  // 3.10

  integer_literal = decimal_integer_literal | hex_integer_literal | octal_integer_literal | binary_integer_literal;
  floating_point_literal = decimal_floating_point_literal | hexadecimal_floating_point_literal;
  boolean_literal = 'true' | 'false';
  character_literal = ''' single_character ''' | ''' escape_sequence ''';
  string_literal = '"' string_character* '"';
  null_literal = 'null';

  // 3.8

  identifier = java_letter java_letter_or_digit*;

  // 3.11

  l_par = '(';
  r_par = ')';
  l_brc = '{';
  r_brc = '}';
  l_bkt = '[';
  r_bkt = ']';
  semi = ';';
  comma = ',';
  dot   = '.';

  // 3.12

  assign = '=';
  lt = '<';
  gt = '>';
  emark = '!';
  tilde = '~';
  qmark = '?';
  colon = ':';

  eq = '==';
  lteq = '<=';
  gteq = '>=';
  neq = '!=';
  amp_amp = '&&';
  bar_bar = '||';
  plus_plus = '++';
  minus_minus = '--';

  plus = '+';
  minus = '-';
  star = '*';
  slash = '/';
  amp = '&';
  bar = '|';
  caret = '^';
  percent = '%';
  shl = '<<';
  shr = '>>';
  ushr = '>>>';

  plus_assign = '+=';
  minus_assign = '-=';
  star_assign = '*=';
  slash_assign = '/=';
  amp_assign = '&=';
  bar_assign = '|=';
  caret_assign = '^=';
  percent_assign = '%=';
  shl_assign = '<<=';
  shr_assign = '>>=';
  ushr_assign = '>>>=';

  // Missing from Chapter 3 of JLS

  dot_dot_dot = '...';
  at = '@';

  // make a single long white_spaces token
  white_spaces = white_space+;


Ignored Tokens

  white_spaces, comment;


Productions

  java_compilation_unit =
    compilation_unit;

  // 3.10

  literal =
    {integer} integer_literal |
    {floating_point} floating_point_literal |
    {boolean} boolean_literal |
    {character} character_literal |
    {string} string_literal |
    {null} null_literal;

  // 4.1

  type =
    {primitive} primitive_type |
    {reference} reference_type;

  type_no_arguments =
    {primitive} primitive_type |
    {reference} reference_type_no_arguments;

  // 4.2

  primitive_type =
    {numeric} numeric_type |
    {boolean} boolean_keyword;

  numeric_type =
    {integral} integral_type |
    {floating} floating_point_type;

  integral_type =
    {byte} byte_keyword |
    {short} short_keyword |
    {int} int_keyword |
    {long} long_keyword |
    {char} char_keyword;

  floating_point_type =
    {float} float_keyword |
    {double} double_keyword;

  // 4.3

  //reference_type =
  //  {class} class_or_interface_type |
  //  {variable} type_variable |
  //  {array} array_type;

  reference_type =
    {class} class_or_interface_type |
    {array} array_type;

  reference_type_no_arguments =
    {class} class_or_interface_type_no_arguments |
    {array} array_type_no_arguments;

  //class_or_interface_type =
  //  {class} class_type |
  //  {interface} interface_type;

  class_or_interface_type_no_arguments = 
    name;

  class_or_interface_type =
    type_decl_specifier type_arguments?;

  class_type =
    type_decl_specifier type_arguments?;

  interface_type =
    type_decl_specifier type_arguments?;

  //type_decl_specifier =
  //  {name} name |
  //  {identifier} class_or_interface_type dot identifier;

  type_decl_specifier {-> type_decl_specifier} =
    name type_decl_specifier_tail* {-> New type_decl_specifier(name.name, [type_decl_specifier_tail.args_with_name])};

  type_decl_specifier_tail {-> args_with_name} =
     type_arguments dot name {-> New args_with_name(type_arguments.type_arguments, name.name)};

  // defined differently in 6.5
  //
  // type_name =
  //   {identifier} identifier |
  //   {type} type_name dot identifier;

  //type_variable =
  //  identifier;

  //array_type =
  //  type l_bkt r_bkt;

  array_type =
    {class} class_or_interface_type dim+ |
    {primitive} primitive_type dim+;

  array_type_no_arguments =
    {class} class_or_interface_type_no_arguments dim+ |
    {primitive} primitive_type dim+;

  // 4.4

  //type_parameter =
  //  type_variable type_bound?;

  type_parameter =
    identifier type_bound?;

  //type_bound =
  //  {variable} extends_keyword type_variable |
  //  {class} extends_keyword class_or_interface_type additional_bound_list?;

  type_bound {-> type_bound} =
    extends_keyword interface_type additional_bound_list? {-> New type_bound([interface_type, additional_bound_list.interface_type])};

  additional_bound_list {-> interface_type*} =
    {list} additional_bound additional_bound_list {-> [additional_bound.interface_type, additional_bound_list.interface_type]}|
    {bound} additional_bound {-> [additional_bound.interface_type]};

  additional_bound {-> interface_type}=
    amp interface_type {-> interface_type};

  // 4.5

  //type_arguments =
  //  lt type_argument_list gt;

  // Take care of the following lexical anomaly:
  //   A<B<C>>  and  A<B<C<D>>>
  // Notice the '>>' and '>>>" tokens.

  type_arguments {-> type_arguments} =
    {gt} lt type_argument_list gt {-> New type_arguments.gt([type_argument_list.type_argument])} |
    {shr} [lt1]:lt type_argument_list_head* type_decl_specifier [lt2]:lt type_argument_list shr {-> New type_arguments.shr([type_argument_list_head.type_argument], type_decl_specifier, [type_argument_list.type_argument])} |
    {ushr} [lt1]:lt [heads1]:type_argument_list_head* [specifier1]:type_decl_specifier [lt2]:lt [heads2]:type_argument_list_head* [specifier2]:type_decl_specifier [lt3]:lt type_argument_list ushr {-> New type_arguments.ushr([heads1.type_argument], specifier1, [heads2.type_argument], specifier2, [type_argument_list.type_argument])};

  //type_argument_list =
  //  {argument} type_argument |
  //  {list} type_argument_list comma type_argument;

  type_argument_list {-> type_argument+} =
    type_argument_list_head* type_argument {-> [type_argument_list_head.type_argument, type_argument]};

  type_argument_list_head {-> type_argument} =
    type_argument comma {-> type_argument};

  type_argument =
    {reference} reference_type |
    {wildcard} wildcard;

  wildcard {-> wildcard} =
    qmark wildcard_bounds? {-> New wildcard(wildcard_bounds.wildcard_bounds)};

  wildcard_bounds {-> wildcard_bounds}=
    {extends} extends_keyword reference_type {-> New wildcard_bounds.extends(reference_type)} |
    {super} super_keyword reference_type {-> New wildcard_bounds.super(reference_type)};

  // 6.5

  // Replaced by name

  //package_name =
  //  {identifier} identifier |
  //  {package} package_name dot identifier;

  //type_name =
  //  {identifier} identifier |
  //  {type} package_or_type_name dot identifier;

  //expression_name =
  //  {identifier} identifier |
  //  {ambiguous} ambiguous_name dot identifier;

  //method_name =
  //  {identifier} identifier |
  //  {ambiguous} ambiguous_name dot identifier;

  //package_or_type_name =
  //  {identifier} identifier |
  //  {type} package_or_type_name dot identifier;

  //ambiguous_name =
  //  {identifier} identifier |
  //  {ambiguous} ambiguous_name dot identifier;

  name {-> name} =
    identifier name_tail? {-> New name([identifier, name_tail.identifier])};

  //name_tail {-> identifier} =
  //  dot identifier {-> identifier};

  name_tail {-> identifier*} =
    {identifier} dot identifier {-> [identifier]} |
    {name} name_tail dot identifier {-> [name_tail.identifier, identifier]};

  // 7.3

  compilation_unit {-> compilation_unit} =
    package_declaration? import_declarations? type_declarations? {-> New compilation_unit(package_declaration.package_declaration, [import_declarations.import_declaration], [type_declarations.type_declaration])};

  import_declarations {-> import_declaration*} =
    {declaration} import_declaration {-> [import_declaration.import_declaration]}|
    {declarations} import_declarations import_declaration {-> [import_declarations.import_declaration, import_declaration.import_declaration]};

  type_declarations {-> type_declaration*}=
    {declaration} type_declaration {-> [type_declaration]} |
    {declarations} type_declarations type_declaration {-> [type_declarations.type_declaration, type_declaration]};

  // 7.4

  //package_declaration =
  //  annotations? package_keyword package_name semi;

  // modifiers? instead of annotations?

  package_declaration {-> package_declaration} =
    modifiers? package_keyword name semi {-> New package_declaration([modifiers.modifier], name.name)};

  // 7.5

  import_declaration {-> import_declaration} =
    {single} single_type_import_declaration {-> single_type_import_declaration.import_declaration}|
    {type} type_import_on_demand_declaration {-> type_import_on_demand_declaration.import_declaration}|
    {static} single_static_import_declaration {-> single_static_import_declaration.import_declaration}|
    {demand} static_import_on_demand_declaration {-> static_import_on_demand_declaration.import_declaration};

  single_type_import_declaration {-> import_declaration} =
    import_keyword name semi {-> New import_declaration.single(name.name)};

  type_import_on_demand_declaration {-> import_declaration} =
    import_keyword name dot star semi {-> New import_declaration.type(name.name)};


  single_static_import_declaration {-> import_declaration} =
    import_keyword static_keyword name semi {-> New import_declaration.static(name.name)};

  static_import_on_demand_declaration {-> import_declaration} =
    import_keyword static_keyword name dot star semi {-> New import_declaration.demand(name.name)};

  // 7.6

 // type_declaration =
 //   {class} class_declaration |
 //   {interface} interface_declaration |
 //   {semi} semi;

  // Modded for Kola

  type_declaration =
    {class} class_declaration |
    {interface} interface_declaration |
    {port} port_declaration |
    {event} event_declaration |
    {component} component_declaration |
    {semi} semi;

  // 8.1

  class_declaration =
    {class} normal_class_declaration |
    {enum} enum_declaration;

  normal_class_declaration {-> normal_class_declaration} =
    modifiers? class_keyword identifier type_parameters? super? interfaces? class_body {-> New normal_class_declaration([modifiers.modifier], identifier, [type_parameters.type_parameter], super.class_type, [interfaces.interface_type], class_body)};

  // Replaced by modifiers production

  //class_modifiers =
  //  {modifier} class_modifier |
  //  {modifiers} class_modifiers class_modifier;

  modifiers {-> modifier*} =
    {modifier} modifier {-> [modifier]}|
    {modifiers} modifiers modifier {-> [modifiers.modifier, modifier]};

  // Replaced by modifier production

  //class_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {protected} protected_keyword |
  //  {private} private_keyword |
  //  {abstract} abstract_keyword |
  //  {static} static_keyword |
  //  {final} final_keyword |
  //  {strictfp} strictfp_keyword;

  modifier =
    {annotation} annotation |
    {public} public_keyword |
    {protected} protected_keyword |
    {private} private_keyword |
    {abstract} abstract_keyword |
    {static} static_keyword |
    {final} final_keyword |
    {strictfp} strictfp_keyword |
    {transient} transient_keyword |
    {volatile} volatile_keyword |
    {synchronized} synchronized_keyword |
    {native} native_keyword;

  type_parameters {-> type_parameter*} =
    lt type_parameter_list gt {-> [type_parameter_list.type_parameter]};

  type_parameter_list {-> type_parameter*} =
    {list} type_parameter_list comma type_parameter {-> [type_parameter_list.type_parameter, type_parameter]}|
    {parameter} type_parameter {-> [type_parameter]};

  super {-> class_type} =
    extends_keyword class_type {-> class_type};

  interfaces {-> interface_type*} =
    implements_keyword interface_type_list {-> [interface_type_list.interface_type]};

  interface_type_list {-> interface_type*} =
    {type} interface_type {-> [interface_type]} |
    {list} interface_type_list comma interface_type {-> [interface_type_list.interface_type, interface_type]};

  class_body {-> class_body} =
    l_brc class_body_declarations? r_brc {-> New class_body([class_body_declarations.class_body_declaration])};

  class_body_declarations {-> class_body_declaration*} =
    {declaration} class_body_declaration {-> [class_body_declaration]} |
    {declarations} class_body_declarations class_body_declaration {-> [class_body_declarations.class_body_declaration, class_body_declaration]};

  class_body_declaration =
    {member} class_member_declaration |
    {instance} instance_initializer |
    {static} static_initializer |
    {constructor} constructor_declaration;

  class_member_declaration =
    {field} field_declaration |
    {method} method_declaration |
    {class} class_declaration |
    {interface} interface_declaration |
    {semi} semi;

  // 8.3

  field_declaration {-> field_declaration} =
    modifiers? type variable_declarators semi {-> New field_declaration([modifiers.modifier], type, [variable_declarators.variable_declarator])};

  variable_declarators {-> variable_declarator*} =
    {declarator} variable_declarator {-> [variable_declarator.variable_declarator]} |
    {declarators} variable_declarators comma variable_declarator {-> [variable_declarators.variable_declarator, variable_declarator.variable_declarator]};

  //variable_declarator =
  //  {id} variable_declarator_id |
  //  {initializer} variable_declarator_id assign variable_initializer;

  variable_declarator {-> variable_declarator} =
    {id} variable_declarator_id {-> New variable_declarator.id(variable_declarator_id)}|
    {initializer} variable_declarator_id assign variable_initializer_no_name {-> New variable_declarator.initializer(variable_declarator_id, variable_initializer_no_name.variable_initializer)}|
    {initializer_name} variable_declarator_id assign name {-> New variable_declarator.initializer(variable_declarator_id, New variable_initializer.expression(New expression.name(name.name)))};

  //variable_declarator_id =
  //  {identifier} identifier |
  //  {variable} variable_declarator_id l_bkt r_bkt;

  variable_declarator_id =
    identifier dim*;

  //variable_initializer =
  //  {expression} expression |
  //  {initializer} array_initializer;

  variable_initializer_no_name {-> variable_initializer} =
    {expression} expression_no_name {-> New variable_initializer.expression(New expression.expression(expression_no_name.expression_no_name))}|
    {initializer} array_initializer {-> New variable_initializer.initializer(array_initializer.array_initializer)};

  // Replaced by modifiers production

  //field_modifiers =
  //  {modifier} field_modifier |
  //  {modifiers} field_modifiers field_modifier;

  // Replaced by modifier production

  //field_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {protected} protected_keyword |
  //  {private} private_keyword |
  //  {static} static_keyword |
  //  {final} final_keyword |
  //  {transient} transient_keyword |
  //  {volatile} volatile_keyword;

  // 8.4

  method_declaration =
    method_header method_body;

  method_header {-> method_header} =
    modifiers? type_parameters? result method_declarator throws? {-> New method_header([modifiers.modifier], [type_parameters.type_parameter], result, method_declarator, throws)};

  //method_declarator =
  //  {identifier} identifier l_par formal_parameter_list? r_par |
  //  {declarator} method_declarator l_bkt r_bkt;

  method_declarator {-> method_declarator} =
    identifier l_par formal_parameter_list? r_par dim* {-> New method_declarator(identifier, formal_parameter_list, [dim])};

  formal_parameter_list {-> formal_parameter_list} =
    {parameter} last_formal_parameter {-> New formal_parameter_list.parameter(last_formal_parameter.last_formal_parameter)}|
    {parameters} formal_parameters comma last_formal_parameter {-> New formal_parameter_list.parameters([formal_parameters.formal_parameter], last_formal_parameter.last_formal_parameter)};

  formal_parameters {-> formal_parameter*} =
    {parameter} formal_parameter {-> [formal_parameter.formal_parameter]}|
    {parameters} formal_parameters comma formal_parameter {-> [formal_parameters.formal_parameter, formal_parameter.formal_parameter]};

  formal_parameter {-> formal_parameter} =
    modifiers? type variable_declarator_id {-> New formal_parameter([modifiers.modifier], type, variable_declarator_id)};

  // Replaced by modifiers production

  //variable_modifiers =
  //  {modifier} variable_modifier |
  //  {modifiers} variable_modifiers variable_modifier;

  // Replaced by modifier production

  //variable_modifier =
  //  {annotation} annotation |
  //  {final} final_keyword;

  last_formal_parameter {-> last_formal_parameter}=
    {variable} modifiers? type dot_dot_dot variable_declarator_id {-> New last_formal_parameter.variable(New formal_parameter([modifiers.modifier], type, variable_declarator_id))} |
    {formal} formal_parameter {-> New last_formal_parameter.formal(formal_parameter.formal_parameter)};

  // Replaced by modifiers production

  //method_modifiers =
  //  {modifier} method_modifier |
  //  {modifiers} method_modifiers method_modifier;

  // Replaced by modifier production

  //method_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {protected} protected_keyword |
  //  {private} private_keyword |
  //  {abstract} abstract_keyword |
  //  {static} static_keyword |
  //  {final} final_keyword |
  //  {synchronized} synchronized_keyword |
  //  {native} native_keyword |
  //  {strictfp} strictfp_keyword;

  result =
    {type} type |
    {void} void_keyword;

  throws {-> throws} =
    throws_keyword exception_type_list {-> New throws([exception_type_list.exception_type])};

  exception_type_list {-> exception_type+} =
    {type} exception_type {-> [exception_type]}|
    {list} exception_type_list comma exception_type {-> [exception_type_list.exception_type, exception_type]};

  //exception_type =
  //  {name} name |
  //  {variable} type_variable;

  exception_type =
    name;

  method_body =
    {block} block |
    {semi} semi;


  // 8.6

  instance_initializer =
    block;

  // 8.7

  static_initializer {-> static_initializer} =
    static_keyword block {-> New static_initializer(block)};

  // 8.8

  constructor_declaration {-> constructor_declaration} =
    modifiers? constructor_declarator throws? constructor_body {-> New constructor_declaration([modifiers.modifier], constructor_declarator.constructor_declarator, throws.throws, constructor_body.constructor_body)};

  constructor_declarator {-> constructor_declarator} =
    type_parameters? simple_type_name l_par formal_parameter_list? r_par {-> New constructor_declarator([type_parameters.type_parameter], simple_type_name, formal_parameter_list)};

  // Missing from JLS

  simple_type_name =
    identifier;

  // Replaced by modifiers production

  //constructor_modifiers =
  //  {modifier} constructor_modifier |
  //  {modifiers} constructor_modifiers constructor_modifier;

  // Replaced by modifier production

  //constructor_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {protected} protected_keyword |
  //  {private} private_keyword;

  constructor_body {-> constructor_body} =
    l_brc explicit_constructor_invocation? block_statements? r_brc {-> New constructor_body(explicit_constructor_invocation, [block_statements.block_statement])};

  explicit_constructor_invocation {-> explicit_constructor_invocation} =
    {this} non_wild_type_arguments? this_keyword l_par argument_list? r_par semi {-> New explicit_constructor_invocation.this([non_wild_type_arguments.reference_type], [argument_list.argument])} |
    {super} non_wild_type_arguments? super_keyword l_par argument_list? r_par semi {-> New explicit_constructor_invocation.super([non_wild_type_arguments.reference_type], [argument_list.argument])}|
    {primary} primary dot non_wild_type_arguments? super_keyword l_par argument_list? r_par semi {-> New explicit_constructor_invocation.primary(primary.expression_no_name, [non_wild_type_arguments.reference_type], [argument_list.argument])};

  non_wild_type_arguments {-> reference_type*} =
    lt reference_type_list gt {-> [reference_type_list.reference_type]};

  reference_type_list {-> reference_type*} =
    {type} reference_type {-> [reference_type]} |
    {list} reference_type_list comma reference_type {-> [reference_type_list.reference_type, reference_type]};

  // 8.9

  enum_declaration {-> enum_declaration} =
    modifiers? enum_keyword identifier interfaces? enum_body {-> New enum_declaration([modifiers.modifier], identifier, [interfaces.interface_type], enum_body.enum_body)};

  enum_body {-> enum_body} =
    l_brc enum_constants? comma? enum_body_declarations? r_brc {-> New enum_body([enum_constants.enum_constant], [enum_body_declarations.class_body_declaration])};

  enum_constants {-> enum_constant*} =
    {constant} enum_constant {-> [enum_constant.enum_constant]} |
    {constants} enum_constants comma enum_constant {-> [enum_constants.enum_constant, enum_constant.enum_constant]};

  //enum_constant =
  //  annotations? identifier arguments? class_body?;

  // modifiers? instead of annotations?

  enum_constant {-> enum_constant} =
    modifiers? identifier arguments? class_body? {-> New enum_constant([modifiers.modifier], identifier, [arguments.argument], class_body)};

  arguments {-> argument*} =
    l_par argument_list? r_par {-> [argument_list.argument]};

  enum_body_declarations {-> class_body_declaration*} =
    semi class_body_declarations? {-> [class_body_declarations.class_body_declaration]};

  // 9.1

  interface_declaration =
    {interface} normal_interface_declaration |
    {annotation} annotation_type_declaration;

  // Includes correction to erroneous split in two alternatives in JLS

  normal_interface_declaration {-> normal_interface_declaration} =
    modifiers? interface_keyword identifier type_parameters? extends_interfaces? interface_body {-> New normal_interface_declaration([modifiers.modifier], identifier, [type_parameters.type_parameter], [extends_interfaces.interface_type], interface_body.interface_body)};

  // Replaced by modifiers production

  //interface_modifiers =
  //  {modifier} interface_modifier |
  //  {modifiers} interface_modifiers interface_modifier;

  // Replaced by modifier production

  //interface_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {protected} protected_keyword |
  //  {private} private_keyword |
  //  {abstract} abstract_keyword |
  //  {static} static_keyword |
  //  {strictfp} strictfp_keyword;

  extends_interfaces {-> interface_type*} =
    extends_keyword interface_type_list {-> [interface_type_list.interface_type]};

  interface_body {-> interface_body} =
    l_brc interface_member_declarations? r_brc {-> New interface_body([interface_member_declarations.interface_member_declaration])};

  interface_member_declarations {-> interface_member_declaration*} =
    {declaration} interface_member_declaration {-> [interface_member_declaration]}|
    {declarations} interface_member_declarations interface_member_declaration {-> [interface_member_declarations.interface_member_declaration, interface_member_declaration]};

  interface_member_declaration =
     {constant} constant_declaration |
     {method} abstract_method_declaration |
     {class} class_declaration |
     {interface} interface_declaration |
     {semi} semi;

  // 9.3

  constant_declaration {-> constant_declaration} =
    modifiers? type variable_declarators semi {-> New constant_declaration([modifiers.modifier], type, [variable_declarators.variable_declarator])};

  // Replaced by modifiers production

  //constant_modifiers =
  //  {modifier} constant_modifier |
  //  {modifiers} constant_modifiers constant_modifier;

  // Replaced by modifier production

  //constant_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {static} static_keyword |
  //  {final} final_keyword;

  // 9.4

  abstract_method_declaration {-> abstract_method_declaration} =
    modifiers? type_parameters? result method_declarator throws? semi {-> New abstract_method_declaration([modifiers.modifier], [type_parameters.type_parameter], result, method_declarator, throws)};

  // Replaced by modifiers production

  //abstract_method_modifiers =
  //  {modifier} abstract_method_modifier |
  //  {modifiers} abstract_method_modifiers abstract_method_modifier;

  // Replaced by modifier production

  //abstract_method_modifier =
  //  {annotation} annotation |
  //  {public} public_keyword |
  //  {abstract} abstract_keyword;

  // 9.6

  annotation_type_declaration {-> annotation_type_declaration} =
    modifiers? at interface_keyword identifier annotation_type_body {-> New annotation_type_declaration([modifiers.modifier], identifier, annotation_type_body.annotation_type_body)};

  annotation_type_body {-> annotation_type_body} =
    l_brc annotation_type_element_declarations? r_brc {-> New annotation_type_body([annotation_type_element_declarations.annotation_type_element_declaration])};

  annotation_type_element_declarations {-> annotation_type_element_declaration*} =
    {declaration} annotation_type_element_declaration {-> [annotation_type_element_declaration.annotation_type_element_declaration]}|
    {declarations} annotation_type_element_declarations annotation_type_element_declaration {-> [annotation_type_element_declarations.annotation_type_element_declaration, annotation_type_element_declaration.annotation_type_element_declaration]};

  //annotation_type_element_declaration =
  //  {abstract} modifiers? type identifier l_par r_par dims? default_value? semi |
  //  {constant} constant_declaration |
  //  {class} class_declaration |
  //  {interface} interface_declaration |
  //  {enum} enum_declaration |
  //  {annotation} annotation_type_declaration |
  //  {semi} semi;

  annotation_type_element_declaration {-> annotation_type_element_declaration} =
    {abstract} modifiers? type identifier l_par r_par dim* default_value? semi {-> New annotation_type_element_declaration.abstract([modifiers.modifier], type, identifier, default_value.element_value)} |
    {constant} constant_declaration {-> New annotation_type_element_declaration.constant(constant_declaration.constant_declaration)} |
    {class} class_declaration {-> New annotation_type_element_declaration.class(class_declaration.class_declaration)} |
    {interface} interface_declaration {-> New annotation_type_element_declaration.interface(interface_declaration.interface_declaration)} |
    {semi} semi {-> New annotation_type_element_declaration.semi(semi)};

  default_value {-> element_value} =
    default_keyword element_value {-> element_value};

  // 9.7

  annotations {-> annotation*}=
    {annotation} annotation {-> [annotation.annotation]}|
    {annotations} annotations annotation {-> [annotations.annotation, annotation.annotation]};

  annotation =
    {normal_annotation} normal_annotation |
    {marker_annotation} marker_annotation |
    {single} single_element_annotation;

  normal_annotation {-> normal_annotation} =
    at name l_par element_value_pairs? r_par {-> New normal_annotation(name.name, [element_value_pairs.element_value_pair])};

  element_value_pairs {-> element_value_pair*} =
    {pair} element_value_pair {-> [element_value_pair.element_value_pair]}|
    {pairs} element_value_pairs comma element_value_pair {-> [element_value_pairs.element_value_pair, element_value_pair.element_value_pair]};

  element_value_pair {-> element_value_pair}=
    identifier assign element_value {-> New element_value_pair(identifier, element_value)};

  //element_value =
  //  {conditional} conditional_expression |
  //  {annotation} annotation |
  //  {array} element_value_array_initializer;

  element_value {-> element_value} =
    {conditional} conditional_expression_no_name {-> New element_value.conditional(New expression.expression(conditional_expression_no_name.expression_no_name))} |
    {name} name {-> New element_value.conditional(New expression.name(name.name))} |
    {annotation} annotation {-> New element_value.annotation(annotation)} |
    {array} element_value_array_initializer {-> New element_value.array(element_value_array_initializer.element_value_array_initializer)};

  element_value_array_initializer {-> element_value_array_initializer} =
    l_brc element_values? comma? r_brc {-> New element_value_array_initializer([element_values.element_value])};

  element_values {-> element_value*} =
    {value} element_value {-> [element_value.element_value]} |
    {values} element_values comma element_value {-> [element_values.element_value, element_value.element_value]};

  marker_annotation {-> marker_annotation} =
    at identifier {-> New marker_annotation(identifier)};

  single_element_annotation {-> single_element_annotation} =
    at identifier l_par element_value r_par {-> New single_element_annotation(identifier, element_value.element_value)};

  // 10.6

  //array_initializer =
  //  l_brc variable_initializers? comma? r_brc;

  array_initializer {-> array_initializer} =
    {variable} l_brc variable_initializers_no_name? comma? r_brc {-> New array_initializer([variable_initializers_no_name.variable_initializer])} |
    {name} l_brc name comma? r_brc {-> New array_initializer([New variable_initializer.expression(New expression.name(name.name))])};

  //variable_initializers =
  //  {initializer} variable_initializer |
  //  {initializers} variable_initializers comma variable_initializer;

  variable_initializers_no_name {-> variable_initializer*} =
    {variable} variable_initializer_no_name variable_initializers_tail* {-> [variable_initializer_no_name.variable_initializer, variable_initializers_tail.variable_initializer]} |
    {name} name variable_initializers_tail+ {-> [New variable_initializer.expression(New expression.name(name.name)), variable_initializers_tail.variable_initializer]};

  variable_initializers_tail {-> variable_initializer} =
    {variable} comma variable_initializer_no_name {-> variable_initializer_no_name.variable_initializer} |
    {name} comma name {-> New variable_initializer.expression(New expression.name(name.name))};

  // 14.2

  block {-> block} =
    l_brc block_statements? r_brc {-> New block([block_statements.block_statement])};

  block_statements {-> block_statement*} =
    {statement} block_statement {-> [block_statement]}|
    {statements} block_statements block_statement {-> [block_statements.block_statement, block_statement]};

  block_statement {-> block_statement} =
    {variable} local_variable_declaration_statement {-> New block_statement.variable(local_variable_declaration_statement.local_variable_declaration)} |
    {class} class_declaration {-> New block_statement.class(class_declaration)} |
    {statement} statement {-> New block_statement.statement(statement)};

  // 14.4

  local_variable_declaration_statement {-> local_variable_declaration} =
    local_variable_declaration semi {-> local_variable_declaration.local_variable_declaration};

  local_variable_declaration {-> local_variable_declaration} =
    modifiers? type variable_declarators {-> New local_variable_declaration([modifiers.modifier], type, [variable_declarators.variable_declarator])};

  // 14.5

  statement =
    {without_trailing_substatement} statement_without_trailing_substatement |
    {labeled_statement} labeled_statement |
    {if} if_then_statement |
    {if_else} if_then_else_statement |
    {while_statement} while_statement |
    {for_statement} for_statement;

//  statement_without_trailing_substatement =
//    {block} block |
//    {empty_statement} empty_statement |
//    {expression_statement} expression_statement |
//   {assert_statement} assert_statement |
//    {switch_statement} switch_statement |
//    {do_statement} do_statement |
//    {break_statement} break_statement |
//    {continue_statement} continue_statement |
//    {return_statement} return_statement |
//    {synchronized_statement} synchronized_statement |
//    {throw_statement} throw_statement |
//    {try_statement} try_statement;

    // Modded for Kola

  statement_without_trailing_substatement {-> statement_without_trailing_substatement} =
    {block} block {-> New statement_without_trailing_substatement.block(block.block)} |
    {empty_statement} empty_statement {-> New statement_without_trailing_substatement.empty_statement()} |
    {expression_statement} expression_statement {-> New statement_without_trailing_substatement.expression_statement(expression_statement.statement_expression)} |
    {assert_statement} assert_statement {-> New statement_without_trailing_substatement.assert_statement(assert_statement.assert_statement)} |
    {switch_statement} switch_statement {-> New statement_without_trailing_substatement.switch_statement(switch_statement.switch_statement)} |
    {do_statement} do_statement {-> New statement_without_trailing_substatement.do_statement(do_statement.do_statement)} |
    {break_statement} break_statement {-> New statement_without_trailing_substatement.break_statement(break_statement.break_statement)} |
    {continue_statement} continue_statement {-> New statement_without_trailing_substatement.continue_statement(continue_statement.continue_statement)} |
    {return_statement} return_statement {-> New statement_without_trailing_substatement.return_statement(return_statement.return_statement)} |
    {synchronized_statement} synchronized_statement {-> New statement_without_trailing_substatement.synchronized_statement(synchronized_statement.synchronized_statement)} |
    {throw_statement} throw_statement {-> New statement_without_trailing_substatement.throw_statement(throw_statement.throw_statement)} |
    {try_statement} try_statement {-> New statement_without_trailing_substatement.try_statement(try_statement.try_statement)} |
    {connect} connect_statement {-> New statement_without_trailing_substatement.connect(connect_statement.connect_statement)} |
    {disconnect} disconnect_statement {-> New statement_without_trailing_substatement.disconnect(disconnect_statement.disconnect_statement)} |
    {subscribe} subscribe_statement {-> New statement_without_trailing_substatement.subscribe(subscribe_statement.subscribe_statement)} |
    {unsubscribe} unsubscribe_statement {-> New statement_without_trailing_substatement.unsubscribe(unsubscribe_statement.unsubscribe_statement)} |
    {trigger} trigger_statement {-> New statement_without_trailing_substatement.trigger(trigger_statement.trigger_statement)};

  statement_no_short_if =
    {without_trailing_substatement} statement_without_trailing_substatement |
    {labeled_statement} labeled_statement_no_short_if |
    {if} if_then_else_statement_no_short_if |
    {while_statement} while_statement_no_short_if |
    {for_statement} for_statement_no_short_if;

  // 14.6

  empty_statement {-> } = semi {-> };

  // 14.7

  labeled_statement {-> labeled_statement} =
    identifier colon statement {-> New labeled_statement(identifier, statement)};

  labeled_statement_no_short_if {-> labeled_statement_no_short_if} =
    identifier colon statement_no_short_if {-> New labeled_statement_no_short_if(identifier, statement_no_short_if)};

  // 14.8

  expression_statement {-> statement_expression} =
    statement_expression semi {-> New statement_expression(statement_expression.expression_no_name)};

  statement_expression {-> expression_no_name} =
    {assignment} assignment {-> assignment.expression_no_name} |
    {pre_increment} pre_increment_expression {-> pre_increment_expression.expression_no_name} |
    {pre_decrement} pre_decrement_expression {-> pre_decrement_expression.expression_no_name} |
    {post_increment} post_increment_expression {-> post_increment_expression.expression_no_name} |
    {post_decrement} post_decrement_expression {-> post_decrement_expression.expression_no_name} |
    {method} method_invocation {-> New expression_no_name.method(method_invocation)} |
    {class} class_instance_creation_expression {-> New expression_no_name.instance(class_instance_creation_expression.class_instance_creation_expression)};

  // 14.9

  //if_then_statement =
  //  if_keyword l_par expression r_par statement;

  if_then_statement {-> if_then_statement} =
    {expression} if_keyword l_par expression_no_name r_par statement {-> New if_then_statement(New expression.expression(expression_no_name.expression_no_name), statement)} |
    {name} if_keyword l_par name r_par statement {-> New if_then_statement(New expression.name(name.name), statement)};

  //if_then_else_statement =
  //  if_keyword l_par expression r_par statement_no_short_if else_keyword statement;

  if_then_else_statement {-> if_then_else_statement} =
    {expression} if_keyword l_par expression_no_name r_par statement_no_short_if else_keyword statement {-> New if_then_else_statement(New expression.expression(expression_no_name.expression_no_name), statement_no_short_if, statement)} |
    {name} if_keyword l_par name r_par statement_no_short_if else_keyword statement {-> New if_then_else_statement(New expression.name(name.name), statement_no_short_if, statement)};

  //if_then_else_statement_no_short_if =
  //  if_keyword l_par expression r_par [then_statement]:statement_no_short_if else_keyword [else_statement]:statement_no_short_if;

  if_then_else_statement_no_short_if {-> if_then_else_statement_no_short_if} =
    {expression} if_keyword l_par expression_no_name r_par [then_statement]:statement_no_short_if else_keyword [else_statement]:statement_no_short_if {-> New if_then_else_statement_no_short_if(New expression.expression(expression_no_name.expression_no_name), then_statement, else_statement)} |
    {name} if_keyword l_par name r_par [then_statement]:statement_no_short_if else_keyword [else_statement]:statement_no_short_if {-> New if_then_else_statement_no_short_if(New expression.name(name.name), then_statement, else_statement)};

  // 14.10

  //assert_statement =
  //  {assert} assert_keyword expression semi |
  //  {expression} assert_keyword [expression1]:expression colon [expression2]:expression semi;

  assert_statement {-> assert_statement} =
    {assert} assert_keyword expression_no_name semi {-> New assert_statement.simple(New expression.expression(expression_no_name.expression_no_name))} |
    {assert_name} assert_keyword name semi {-> New assert_statement.simple(New expression.name(name.name))} |
    {expression} assert_keyword [expression1]:expression_no_name colon [expression2]:expression_no_name semi {-> New assert_statement.details(New expression.expression(expression1.expression_no_name), New expression.expression(expression2.expression_no_name))} |
    {expression_name2} assert_keyword [expression1]:expression_no_name colon [expression2]:name semi {-> New assert_statement.details(New expression.expression(expression1.expression_no_name), New expression.name(expression2.name))} |
    {expression_name1} assert_keyword [expression1]:name colon [expression2]:expression_no_name semi {-> New assert_statement.details(New expression.name(expression1.name), New expression.expression(expression2.expression_no_name))} |
    {expression_name1_name2} assert_keyword [expression1]:name colon [expression2]:name semi {-> New assert_statement.details(New expression.name(expression1.name), New expression.name(expression2.name))};

  // 14.11

  //switch_statement =
  //  switch_keyword l_par expression r_par switch_block;

  switch_statement {-> switch_statement} =
    {expression} switch_keyword l_par expression_no_name r_par switch_block {-> New switch_statement(New expression.expression(expression_no_name.expression_no_name), switch_block.switch_block)} |
    {name} switch_keyword l_par name r_par switch_block {-> New switch_statement(New expression.name(name.name), switch_block.switch_block)};

  switch_block {-> switch_block} =
    l_brc switch_block_statement_groups? switch_labels? r_brc {-> New switch_block([switch_block_statement_groups.switch_block_statement_group], [switch_labels.switch_label])};

  switch_block_statement_groups {-> switch_block_statement_group*} =
    {group} switch_block_statement_group {-> [switch_block_statement_group.switch_block_statement_group]} |
    {groups} switch_block_statement_groups switch_block_statement_group {-> [switch_block_statement_groups.switch_block_statement_group, switch_block_statement_group.switch_block_statement_group]};

  switch_block_statement_group {-> switch_block_statement_group} =
    switch_labels block_statements {-> New switch_block_statement_group([switch_labels.switch_label], [block_statements.block_statement])};

  switch_labels {-> switch_label*} =
    {label} switch_label {-> [switch_label.switch_label]} |
    {labels} switch_labels switch_label {-> [switch_labels.switch_label, switch_label.switch_label]};

  //switch_label =
  //  {constant} case_keyword constant_expression colon |
  //  {enum} case_keyword enum_constant_name colon |
  //  {default} default_keyword colon;

  //switch_label =
  //  {constant} case_keyword constant_expression_no_name colon |
  //  {constant_name} case_keyword name colon |
  //  {enum} case_keyword enum_constant_name colon |
  //  {default} default_keyword colon;

  switch_label {-> switch_label} =
    {constant} case_keyword constant_expression_no_name colon {-> New switch_label.constant(constant_expression_no_name)} |
    {constant_name} case_keyword name colon {-> New switch_label.constant_name(name.name)} |
    {default} default_keyword colon {-> New switch_label.default(default_keyword)};

  //enum_constant_name =
  //  identifier;

  // 14.12

  //while_statement =
  //  while_keyword l_par expression r_par statement;

  while_statement {-> while_statement} =
    {expression} while_keyword l_par expression_no_name r_par statement {-> New while_statement(New expression.expression(expression_no_name.expression_no_name), statement)} |
    {name} while_keyword l_par name r_par statement {-> New while_statement(New expression.name(name.name), statement)};

  //while_statement_no_short_if =
  //  while_keyword l_par expression r_par statement_no_short_if;

  while_statement_no_short_if {-> while_statement_no_short_if} =
    {expression} while_keyword l_par expression_no_name r_par statement_no_short_if {-> New while_statement_no_short_if(New expression.expression(expression_no_name.expression_no_name), statement_no_short_if)} |
    {name} while_keyword l_par name r_par statement_no_short_if {-> New while_statement_no_short_if(New expression.name(name.name), statement_no_short_if)};

  // 14.13

  //do_statement =
  //  do_keyword statement while_keyword l_par expression r_par semi;

  do_statement {-> do_statement} =
    {expression} do_keyword statement while_keyword l_par expression_no_name r_par semi {-> New do_statement(statement, New expression.expression(expression_no_name.expression_no_name))}|
    {name} do_keyword statement while_keyword l_par name r_par semi {-> New do_statement(statement, New expression.name(name.name))};

  // 14.4

  for_statement =
    {basic_for} basic_for_statement |
    {enhanced_for} enhanced_for_statement;

  //basic_for_statement =
  //  for_keyword l_par for_init? [semi1]:semi expression? [semi2]:semi for_update? r_par statement;

  basic_for_statement {-> basic_for_statement} =
    {expression} for_keyword l_par for_init? [semi1]:semi expression_no_name? [semi2]:semi for_update? r_par statement {-> New basic_for_statement.expression(for_init.for_init, expression_no_name.expression_no_name, for_update.for_update, statement)} |
    {name} for_keyword l_par for_init? [semi1]:semi name [semi2]:semi for_update? r_par statement {-> New basic_for_statement.name(for_init.for_init, name.name, for_update.for_update, statement)};

  //for_statement_no_short_if =
  //  for_keyword l_par for_init? [semi1]:semi expression? [semi2]:semi for_update? r_par statement_no_short_if;

  for_statement_no_short_if {-> for_statement_no_short_if} =
    {expression} for_keyword l_par for_init? [semi1]:semi expression_no_name? [semi2]:semi for_update? r_par statement_no_short_if {-> New for_statement_no_short_if.expression(for_init.for_init, expression_no_name.expression_no_name, for_update.for_update, statement_no_short_if)} |
    {name} for_keyword l_par for_init? [semi1]:semi name [semi2]:semi for_update? r_par statement_no_short_if {-> New for_statement_no_short_if.name(for_init.for_init, name.name, for_update.for_update, statement_no_short_if)};

  for_init {-> for_init} =
    {statement} statement_expression_list {-> New for_init.statement([statement_expression_list.expression_no_name])} |
    {local} local_variable_declaration {-> New for_init.local(local_variable_declaration)};

  for_update {-> for_update} =
    statement_expression_list {-> New for_update([statement_expression_list.expression_no_name])};

  statement_expression_list {-> expression_no_name+} =
    {expression} statement_expression {-> [statement_expression.expression_no_name]} |
    {list} statement_expression_list comma statement_expression {-> [statement_expression_list.expression_no_name, statement_expression.expression_no_name]};

  //enhanced_for_statement =
  //  for_keyword l_par formal_parameter colon expression r_par statement;

  enhanced_for_statement {-> enhanced_for_statement} =
    {expression} for_keyword l_par formal_parameter colon expression_no_name r_par statement {-> New enhanced_for_statement(formal_parameter, New expression.expression(expression_no_name.expression_no_name), statement)} |
    {name} for_keyword l_par formal_parameter colon name r_par statement {-> New enhanced_for_statement(formal_parameter, New expression.name(name.name), statement)};

  // 14.15

  break_statement {-> break_statement} =
    break_keyword identifier? semi {-> New break_statement(identifier)};

  // 14.16

  continue_statement {-> continue_statement} =
    continue_keyword identifier? semi {-> New continue_statement(identifier)};

  // 14.17

  //return_statement =
  //  return_keyword expression? semi;

  return_statement {-> return_statement} =
    {expression} return_keyword expression_no_name semi {-> New return_statement.expression(New expression.expression(expression_no_name.expression_no_name))} |
    {name} return_keyword name semi {-> New return_statement.expression(New expression.name(name.name))} |
    {void} return_keyword semi {-> New return_statement.void()};

  // 14.18

  //throw_statement =
  //  throw_keyword expression semi;

  throw_statement {-> throw_statement} =
    {expression} throw_keyword expression_no_name semi {-> New throw_statement(New expression.expression(expression_no_name.expression_no_name))} |
    {name} throw_keyword name semi {-> New throw_statement(New expression.name(name.name))};

  // 14.19

  //synchronized_statement =
  //  synchronized_keyword l_par expression r_par block;

  synchronized_statement {-> synchronized_statement} =
    {expression} synchronized_keyword l_par expression_no_name r_par block {-> New synchronized_statement(New expression.expression(expression_no_name.expression_no_name), block.block)} |
    {name} synchronized_keyword l_par name r_par block {-> New synchronized_statement(New expression.name(name.name), block.block)};

  // 14.20

  try_statement {-> try_statement} =
    {catch} try_keyword block catches {-> New try_statement.catch(block.block, [catches.catch_clause])} |
    {finally} try_keyword block catches? finally {-> New try_statement.finally(block.block, [catches.catch_clause], finally.finally)}|
    {resources} try_with_resources_statement {-> New try_statement.resources(try_with_resources_statement.try_with_resources_statement)};

  catches {-> catch_clause+} =
    {clause} catch_clause {-> [catch_clause.catch_clause]} |
    {catches} catches catch_clause {-> [catches.catch_clause, catch_clause.catch_clause]};

  catch_clause {-> catch_clause} =
    catch_keyword l_par catch_formal_parameter r_par block {-> New catch_clause(catch_formal_parameter.catch_formal_parameter, block.block)};

  catch_formal_parameter {-> catch_formal_parameter} =
    modifiers? catch_type variable_declarator_id {-> New catch_formal_parameter([modifiers.modifier], [catch_type.class_type], variable_declarator_id)} ;

  catch_type {-> class_type+} =
    {class} class_type {-> [class_type]} |
    {catch} class_type bar catch_type {-> [class_type, catch_type.class_type]};

  finally {-> finally} =
    finally_keyword block {-> New finally(block.block)};

  try_with_resources_statement {-> try_with_resources_statement} =
    try_keyword resource_specification block variable_declarator_id catches? finally? {-> New try_with_resources_statement(resource_specification.resource_specification, block.block, variable_declarator_id, [catches.catch_clause], finally.finally)};

  resource_specification {-> resource_specification} =
    l_par resources semi? r_par {-> New resource_specification([resources.resource])};

  //resources =
  //  {resource} resource |
  //  {resources} resource semi resources;

  // use left recursion, instead of right recursion

  resources {-> resource+} =
    {resource} resource {-> [resource.resource]} |
    {resources} resources semi resource {-> [resources.resource, resource.resource]};

  //resource =
  //  modifiers? type variable_declarator_id assign expression;

  resource {-> resource} =
    {expression} modifiers? type variable_declarator_id assign expression_no_name {-> New resource([modifiers.modifier], type, variable_declarator_id, New expression.expression(expression_no_name.expression_no_name))} |
    {name} modifiers? type variable_declarator_id assign name {-> New resource([modifiers.modifier], type, variable_declarator_id, New expression.name(name.name))};

  // 15.8

  primary {-> expression_no_name} =
    {primary} primary_no_new_array {-> primary_no_new_array.expression_no_name} |
    {array} array_creation_expression {-> New expression_no_name.array_creation(array_creation_expression.array_creation_expression)};

  //primary_no_new_array =
  //  {literal} literal |
  //  {type} type dot class_keyword |
  //  {void} void_keyword dot class_keyword |
  //  {this} this_keyword |
  //  {class} class_name dot this_keyword |
  //  {expression} l_par expression r_par |
  //  {instance} class_instance_creation_expression |
  //  {field} field_access |
  //  {method} method_invocation |
  //  {array} array_access;

  // The LL grammar in the JLS appendix does not accept reference
  // types with type arguments in the following alternative:
  //   {type} type dot class_keyword
  // In other words, the following code is invalid:
  //   Class c = A<B>.class
  // This contradicts the definition in 15.8.
  // But, we modify the grammar accordingly, to eliminate
  // the local ambiguity caused by not knowing whether "<" indicates
  // a "less-than" expression or a type argument.

  primary_no_new_array {-> expression_no_name} =
    {literal} literal {-> New expression_no_name.literal(literal)} |
    {type} type_no_arguments dot class_keyword {-> New expression_no_name.type(type_no_arguments)} |
    {void} void_keyword dot class_keyword {-> New expression_no_name.void()} |
    {this} this_keyword {-> New expression_no_name.this()} |
    {class} class_name dot this_keyword {-> New expression_no_name.class(class_name)} |
    {expression} l_par expression_no_name r_par {-> New expression_no_name.expression(New expression.expression(expression_no_name.expression_no_name))} |
    {expression_name} l_par name r_par {-> New expression_no_name.expression(New expression.name(name.name))} |
    {instance} class_instance_creation_expression {-> New expression_no_name.instance(class_instance_creation_expression.class_instance_creation_expression)} |
    {field} field_access {-> New expression_no_name.field(field_access)} |
    {method} method_invocation {-> New expression_no_name.method(method_invocation)} |
    {array} array_access {-> New expression_no_name.array(array_access)};

  // Missing from JLS

  class_name =
    name;

  // 15.9

  class_instance_creation_expression {-> class_instance_creation_expression} =
    {new} new_keyword type_arguments? type_decl_specifier type_arguments_or_diamond? l_par argument_list? r_par class_body? {-> New class_instance_creation_expression.new(type_arguments, type_decl_specifier, type_arguments_or_diamond, [argument_list.argument], class_body.class_body)} |
    {primary} primary dot new_keyword type_arguments? identifier type_arguments_or_diamond? l_par argument_list? r_par class_body? {-> New class_instance_creation_expression.primary(primary.expression_no_name, type_arguments, identifier, type_arguments_or_diamond, [argument_list.argument], class_body.class_body)};

  type_arguments_or_diamond {-> type_arguments_or_diamond} =
    {type_arguments} type_arguments {-> New type_arguments_or_diamond.type_arguments(type_arguments)} |
    {diamond} lt gt {-> New type_arguments_or_diamond.diamond()};

  //argument_list =
  //  {expression} expression |
  //  {list} argument_list comma expression;

  argument_list {-> argument*} =
    {expression} expression_no_name argument_list_tail* {-> [New argument.expression(expression_no_name), argument_list_tail.argument]}|
    {name} name argument_list_tail* {-> [New argument.name(name.name), argument_list_tail.argument]};

  argument_list_tail {-> argument} =
    {expression} comma expression_no_name {-> New argument.expression(expression_no_name)}|
    {name} comma name {-> New argument.name(name.name)};

  // 15.10

  array_creation_expression {-> array_creation_expression} =
    {primitive} new_keyword primitive_type dim_exprs dim* {-> New array_creation_expression.primitive(primitive_type, [dim_exprs.dim_expr], [dim])} |
    {class} new_keyword class_or_interface_type dim_exprs dim* {-> New array_creation_expression.class(class_or_interface_type, [dim_exprs.dim_expr], [dim])} |
    {primitive_initializer} new_keyword primitive_type dim+ array_initializer {-> New array_creation_expression.primitive_initializer(primitive_type, [dim], array_initializer)} |
    {class_initializer} new_keyword class_or_interface_type dim+ array_initializer {-> New array_creation_expression.class_initializer(class_or_interface_type, [dim], array_initializer)};

  dim_exprs {-> dim_expr+} =
    {expr} dim_expr {-> [dim_expr.dim_expr]} |
    {exprs} dim_exprs dim_expr {-> [dim_exprs.dim_expr, dim_expr.dim_expr]};

  //dim_expr =
  //  l_bkt expression r_bkt;

  dim_expr {-> dim_expr} =
    {expression} l_bkt expression_no_name r_bkt {-> New dim_expr(New expression.expression(expression_no_name.expression_no_name))} |
    {name} l_bkt name r_bkt {-> New dim_expr(New expression.name(name.name))};

  //dims =
  //  {dim} l_bkt r_bkt |
  //  {dims} dims l_bkt r_bkt;

  dim {-> dim}=
    l_bkt r_bkt {-> New dim()};

  // 15.11

  field_access {-> field_access} =
    {primary} primary dot identifier {-> New field_access.primary(primary.expression_no_name, identifier)} |
    {super} super_keyword dot identifier {-> New field_access.super(identifier)} |
    {class} class_name [dot1]:dot super_keyword [dot2]:dot identifier {-> New field_access.class(class_name, identifier)};

  // 15.12

  method_invocation {-> method_invocation} =
    {method} name l_par argument_list? r_par {-> New method_invocation.method(name.name, [argument_list.argument])} |
    {primary} primary dot non_wild_type_arguments? identifier l_par argument_list? r_par {-> New method_invocation.primary(primary.expression_no_name, [non_wild_type_arguments.reference_type], identifier, [argument_list.argument])} |
    {super} super_keyword dot non_wild_type_arguments? identifier l_par argument_list? r_par {-> New method_invocation.super([non_wild_type_arguments.reference_type], identifier, [argument_list.argument])}|
    {class} class_name [dot1]:dot super_keyword [dot2]:dot non_wild_type_arguments? identifier l_par argument_list? r_par {-> New method_invocation.class(class_name, [non_wild_type_arguments.reference_type], identifier, [argument_list.argument])} |
    {type} name dot non_wild_type_arguments identifier l_par argument_list? r_par {-> New method_invocation.type(name.name, [non_wild_type_arguments.reference_type], identifier, [argument_list.argument])};

  // 15.13

  //array_access =
  //  {expression} name l_bkt expression r_bkt |
  //  {primary} primary_no_new_array l_bkt expression r_bkt;

  array_access {-> array_access} =
    {expression} name l_bkt expression_no_name r_bkt {-> New array_access(New expression.name(name.name), New expression.expression(expression_no_name.expression_no_name))} |
    {expression_name} [name1]:name l_bkt [name2]:name r_bkt {-> New array_access(New expression.name(name1.name), New expression.name(name2.name))} |
    {primary} primary_no_new_array l_bkt expression_no_name r_bkt {-> New array_access(New expression.expression(primary_no_new_array.expression_no_name), New expression.expression(expression_no_name.expression_no_name))} |
    {primary_name} primary_no_new_array l_bkt name r_bkt {-> New array_access(New expression.expression(primary_no_new_array.expression_no_name), New expression.name(name.name))};

  // 15.14

  //postfix_expression =
  //  {primary} primary |
  //  {expression} name |
  //  {increment} post_increment_expression |
  //  {decrement} post_decrement_expression;

  postfix_expression_no_name {-> expression_no_name} =
    {primary} primary {-> primary.expression_no_name} |
    {increment} post_increment_expression {-> post_increment_expression.expression_no_name} |
    {decrement} post_decrement_expression {-> post_decrement_expression.expression_no_name};

  //post_increment_expression =
  //  postfix_expression plus_plus;

  post_increment_expression {-> expression_no_name} =
    {postfix} postfix_expression_no_name plus_plus {-> New expression_no_name.post_inc(New expression.expression(postfix_expression_no_name.expression_no_name))} |
    {name} name plus_plus {-> New expression_no_name.post_inc(New expression.name(name.name))};

  //post_decrement_expression =
  //  postfix_expression minus_minus;

  post_decrement_expression {-> expression_no_name} =
    {postfix} postfix_expression_no_name minus_minus {-> New expression_no_name.post_decr(New expression.expression(postfix_expression_no_name.expression_no_name))} |
    {name} name minus_minus {-> New expression_no_name.post_decr(New expression.name(name.name))};

  // 15.15

  //unary_expression =
  // {increment} pre_increment_expression |
  // {decrement} pre_decrement_expression |
  // {plus} plus unary_expression |
  // {minus} minus unary_expression |
  // {unary} unary_expression_not_plus_minus;

  unary_expression_no_name {-> expression_no_name} =
   {increment} pre_increment_expression {-> pre_increment_expression.expression_no_name} |
   {decrement} pre_decrement_expression {-> pre_decrement_expression.expression_no_name} |
   {plus} plus unary_expression_no_name {-> New expression_no_name.uplus(New expression.expression(unary_expression_no_name.expression_no_name))} |
   {plus_name} plus name {-> New expression_no_name.uplus(New expression.name(name.name))} |
   {minus} minus unary_expression_no_name {-> New expression_no_name.uminus(New expression.expression(unary_expression_no_name.expression_no_name))} |
   {minus_name} minus name {-> New expression_no_name.uminus(New expression.name(name.name))} |
   {unary} unary_expression_not_plus_minus_no_name {-> unary_expression_not_plus_minus_no_name.expression_no_name};

  //pre_increment_expression =
  //  plus_plus unary_expression;

  pre_increment_expression {-> expression_no_name} =
    {unary} plus_plus unary_expression_no_name {-> New expression_no_name.pre_inc(New expression.expression(unary_expression_no_name.expression_no_name))} |
    {name} plus_plus name {-> New expression_no_name.pre_inc(New expression.name(name.name))};

  //pre_decrement_expression =
  //  minus_minus unary_expression;

  pre_decrement_expression {-> expression_no_name} =
    {unary} minus_minus unary_expression_no_name {-> New expression_no_name.pre_decr(New expression.expression(unary_expression_no_name.expression_no_name))}|
    {name} minus_minus name {-> New expression_no_name.pre_decr(New expression.name(name.name))};

  //unary_expression_not_plus_minus =
  //  {postfix} postfix_expression |
  //  {tilde} tilde unary_expression |
  //  {emark} emark unary_expression |
  //  {cast} cast_expression;

  unary_expression_not_plus_minus_no_name {-> expression_no_name} =
    {postfix} postfix_expression_no_name {-> postfix_expression_no_name.expression_no_name} |
    {tilde} tilde unary_expression_no_name {-> New expression_no_name.tilde(New expression.expression(unary_expression_no_name.expression_no_name))} |
    {tilde_name} tilde name {-> New expression_no_name.tilde(New expression.name(name.name))} |
    {emark} emark unary_expression_no_name {-> New expression_no_name.emark(New expression.expression(unary_expression_no_name.expression_no_name))} |
    {emark_name} emark name {-> New expression_no_name.emark(New expression.name(name.name))} |
    {cast} cast_expression {-> cast_expression.expression_no_name};

  // 15.16

  //cast_expression =
  //  {primitive} l_par primitive_type r_par unary_expression |
  //  {reference} l_par reference_type r_par unary_expression_not_plus_minus;

  cast_expression {->  expression_no_name} =
    {primitive} l_par primitive_type r_par unary_expression_no_name {-> New expression_no_name.pcast(primitive_type, New expression.expression(unary_expression_no_name.expression_no_name))} |
    {primitive_name} l_par primitive_type r_par name {-> New expression_no_name.pcast(primitive_type, New expression.name(name.name))} |
    {reference} l_par reference_type r_par unary_expression_not_plus_minus_no_name {-> New expression_no_name.rcast(reference_type, New expression.expression(unary_expression_not_plus_minus_no_name.expression_no_name))} |
    {reference_name} l_par reference_type r_par name {-> New expression_no_name.rcast(reference_type, New expression.name(name.name))};

  // 15.17

  //multiplicative_expression =
  //  {unary} unary_expression |
  //  {star} multiplicative_expression star unary_expression |
  //  {slash} multiplicative_expression slash unary_expression |
  //  {percent} multiplicative_expression percent unary_expression;

  multiplicative_expression_no_name {-> expression_no_name} =
    {unary} unary_expression_no_name {-> unary_expression_no_name.expression_no_name} |
    {star} [left]:multiplicative_expression_no_name star [right]:unary_expression_no_name {-> New expression_no_name.mul(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {star_name} [left]:multiplicative_expression_no_name star [right]:name {-> New expression_no_name.mul(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_star} [left]:name star [right]:unary_expression_no_name {-> New expression_no_name.mul(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_star_name} [left]:name star [right]:name {-> New expression_no_name.mul(New expression.name(left.name), New expression.name(right.name))} |
    {slash} [left]:multiplicative_expression_no_name slash [right]:unary_expression_no_name {-> New expression_no_name.div(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {slash_name} [left]:multiplicative_expression_no_name slash [right]:name {-> New expression_no_name.div(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_slash} [left]:name slash [right]:unary_expression_no_name {-> New expression_no_name.div(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_slash_name} [left]:name slash [right]:name {-> New expression_no_name.div(New expression.name(left.name), New expression.name(right.name))} |
    {percent} [left]:multiplicative_expression_no_name percent [right]:unary_expression_no_name {-> New expression_no_name.mod(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {percent_name} [left]:multiplicative_expression_no_name percent [right]:name {-> New expression_no_name.mod(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_percent} [left]:name percent [right]:unary_expression_no_name {-> New expression_no_name.mod(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_percent_name} [left]:name percent [right]:name {-> New expression_no_name.mod(New expression.name(left.name), New expression.name(right.name))};

  // 15.18

  //additive_expression =
  //  {multiplicative} multiplicative_expression |
  //  {plus} additive_expression plus multiplicative_expression |
  //  {minus} additive_expression minus multiplicative_expression;

  additive_expression_no_name {-> expression_no_name} =
    {multiplicative} multiplicative_expression_no_name {-> multiplicative_expression_no_name.expression_no_name} |
    {plus} [left]:additive_expression_no_name plus [right]:multiplicative_expression_no_name {-> New expression_no_name.plus(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {plus_name} [left]:additive_expression_no_name plus [right]:name {-> New expression_no_name.plus(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_plus} [left]:name plus [right]:multiplicative_expression_no_name {-> New expression_no_name.plus(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_plus_name} [left]:name plus [right]:name {-> New expression_no_name.plus(New expression.name(left.name), New expression.name(right.name))} |
    {minus} [left]:additive_expression_no_name minus [right]:multiplicative_expression_no_name {-> New expression_no_name.minus(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {minus_name} [left]:additive_expression_no_name minus [right]:name {-> New expression_no_name.minus(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_minus} [left]:name minus [right]:multiplicative_expression_no_name {-> New expression_no_name.minus(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_minus_name} [left]:name minus [right]:name {-> New expression_no_name.minus(New expression.name(left.name), New expression.name(right.name))};

  // 15.19

  //shift_expression =
  //  {additive} additive_expression |
  //  {shl} shift_expression shl additive_expression |
  //  {shr} shift_expression shr additive_expression |
  //  {ushr} shift_expression ushr additive_expression;

  shift_expression_no_name {-> expression_no_name} =
    {additive} additive_expression_no_name {-> additive_expression_no_name.expression_no_name} |
    {shl} [left]:shift_expression_no_name shl [right]:additive_expression_no_name {-> New expression_no_name.shl(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {shl_name} [left]:shift_expression_no_name shl [right]:name {-> New expression_no_name.shl(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_shl} [left]:name shl [right]:additive_expression_no_name {-> New expression_no_name.shl(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_shl_name} [left]:name shl [right]:name {-> New expression_no_name.shl(New expression.name(left.name), New expression.name(right.name))} |
    {shr} [left]:shift_expression_no_name shr [right]:additive_expression_no_name {-> New expression_no_name.shr(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {shr_name} [left]:shift_expression_no_name shr [right]:name {-> New expression_no_name.shr(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_shr} [left]:name shr [right]:additive_expression_no_name {-> New expression_no_name.shr(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_shr_name} [left]:name shr [right]:name {-> New expression_no_name.shr(New expression.name(left.name), New expression.name(right.name))} |
    {ushr} [left]:shift_expression_no_name ushr [right]:additive_expression_no_name {-> New expression_no_name.ushr(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {ushr_name} [left]:shift_expression_no_name ushr [right]:name {-> New expression_no_name.ushr(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_ushr} [left]:name ushr [right]:additive_expression_no_name {-> New expression_no_name.ushr(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_ushr_name} [left]:name ushr [right]:name {-> New expression_no_name.ushr(New expression.name(left.name), New expression.name(right.name))};

  // 15.20

  //relational_expression =
  //  {shift}     shift_expression |
  //  {lt} relational_expression lt shift_expression |
  //  {gt} relational_expression gt shift_expression |
  //  {lteq} relational_expression lteq shift_expression |
  //  {gteq} relational_expression gteq shift_expression |
  //  {instanceof} relational_expression instanceof_keyword reference_type;

  // There's a problem case to deal with:
  //   ... a instanceof B < ...
  // causes a conflict, but we know that, semantically, the result of
  // instanceof is a boolean, so we assume the "<" is the start of a
  // type parameter, not the "less than" operator.

  relational_expression_no_name {-> expression_no_name} =
    {no_instanceof} relational_expression_no_name_no_instanceof {-> relational_expression_no_name_no_instanceof.expression_no_name} |
    {instanceof} [left]:relational_expression_no_name instanceof_keyword [right]:reference_type {-> New expression_no_name.instanceof(New expression.expression(left.expression_no_name), right)} |
    {name_instanceof} [left]:name instanceof_keyword [right]:reference_type {-> New expression_no_name.instanceof(New expression.name(left.name), right)} ;

  // WARNING: the production was rewritten as right associative
  // to eliminate conflicts.

  relational_expression_no_name_no_instanceof {-> expression_no_name} =
    {shift} shift_expression_no_name {-> shift_expression_no_name.expression_no_name} |
    {lt} [left]:shift_expression_no_name lt [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.lt(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {lt_name} [left]:shift_expression_no_name lt [right]:name {-> New expression_no_name.lt(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_lt} [left]:name lt [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.lt(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_lt_name} [left]:name lt [right]:name {-> New expression_no_name.lt(New expression.name(left.name), New expression.name(right.name))} |
    {gt} [left]:shift_expression_no_name gt [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.gt(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {gt_name} [left]:shift_expression_no_name gt [right]:name {-> New expression_no_name.gt(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_gt} [left]:name gt [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.gt(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_gt_name} [left]:name gt [right]:name {-> New expression_no_name.gt(New expression.name(left.name), New expression.name(right.name))} |
    {lteq} [left]:shift_expression_no_name lteq [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.lteq(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {lteq_name} [left]:shift_expression_no_name lteq [right]:name {-> New expression_no_name.lteq(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_lteq} [left]:name lteq [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.lteq(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_lteq_name} [left]:name lteq [right]:name {-> New expression_no_name.lteq(New expression.name(left.name), New expression.name(right.name))} |
    {gteq} [left]:shift_expression_no_name gteq [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.gteq(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {gteq_name} [left]:shift_expression_no_name gteq [right]:name {-> New expression_no_name.gteq(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_gteq} [left]:name gteq [right]:relational_expression_no_name_no_instanceof {-> New expression_no_name.gteq(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_gteq_name} [left]:name gteq [right]:name {-> New expression_no_name.gteq(New expression.name(left.name), New expression.name(right.name))};

  // 15.21

  //equality_expression =
  //  {relational} relational_expression |
  //  {eq} equality_expression eq relational_expression |
  //  {neq} equality_expression neq relational_expression;

  equality_expression_no_name {-> expression_no_name} =
    {relational} relational_expression_no_name {-> relational_expression_no_name.expression_no_name} |
    {eq} [left]:equality_expression_no_name eq [right]:relational_expression_no_name {-> New expression_no_name.eq(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {eq_name} [left]:equality_expression_no_name eq [right]:name {-> New expression_no_name.eq(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_eq} [left]:name eq [right]:relational_expression_no_name {-> New expression_no_name.eq(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_eq_name} [left]:name eq [right]:name {-> New expression_no_name.eq(New expression.name(left.name), New expression.name(right.name))} |
    {neq} [left]:equality_expression_no_name neq [right]:relational_expression_no_name {-> New expression_no_name.neq(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {neq_name} [left]:equality_expression_no_name neq [right]:name {-> New expression_no_name.neq(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_neq} [left]:name neq [right]:relational_expression_no_name {-> New expression_no_name.neq(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_neq_name} [left]:name neq [right]:name {-> New expression_no_name.neq(New expression.name(left.name), New expression.name(right.name))};

  // 15.22

  //and_expression =
  //  {equality} equality_expression |
  //  {amp} and_expression amp equality_expression;

  and_expression_no_name {-> expression_no_name} =
    {equality} equality_expression_no_name {-> equality_expression_no_name.expression_no_name} |
    {amp} [left]:and_expression_no_name amp [right]:equality_expression_no_name {-> New expression_no_name.and(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {amp_name} [left]:and_expression_no_name amp [right]:name {-> New expression_no_name.and(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_amp} [left]:name amp [right]:equality_expression_no_name {-> New expression_no_name.and(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_amp_name} [left]:name amp [right]:name {-> New expression_no_name.and(New expression.name(left.name), New expression.name(right.name))};

  //exclusive_or_expression =
  //  {and} and_expression |
  //  {caret} exclusive_or_expression caret and_expression;

  exclusive_or_expression_no_name {-> expression_no_name} =
    {and} and_expression_no_name {-> and_expression_no_name.expression_no_name} |
    {caret} [left]:exclusive_or_expression_no_name caret [right]:and_expression_no_name {-> New expression_no_name.eor(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {caret_name} [left]:exclusive_or_expression_no_name caret [right]:name {-> New expression_no_name.eor(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_caret} [left]:name caret [right]:and_expression_no_name {-> New expression_no_name.eor(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_caret_name} [left]:name caret [right]:name {-> New expression_no_name.eor(New expression.name(left.name), New expression.name(right.name))};

  //inclusive_or_expression =
  //  {or} exclusive_or_expression |
  //  {bar} inclusive_or_expression bar exclusive_or_expression;

  inclusive_or_expression_no_name {-> expression_no_name} =
    {or} exclusive_or_expression_no_name {-> exclusive_or_expression_no_name.expression_no_name} |
    {bar} [left]:inclusive_or_expression_no_name bar [right]:exclusive_or_expression_no_name {-> New expression_no_name.ior(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {bar_name} [left]:inclusive_or_expression_no_name bar [right]:name {-> New expression_no_name.ior(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_bar} [left]:name bar [right]:exclusive_or_expression_no_name {-> New expression_no_name.ior(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_bar_name} [left]:name bar [right]:name {-> New expression_no_name.ior(New expression.name(left.name), New expression.name(right.name))};

  // 15.23

  //conditional_and_expression =
  //  {or} inclusive_or_expression |
  //  {amp} conditional_and_expression amp_amp inclusive_or_expression;

  conditional_and_expression_no_name {-> expression_no_name} =
    {or} inclusive_or_expression_no_name {-> inclusive_or_expression_no_name.expression_no_name} |
    {amp} [left]:conditional_and_expression_no_name amp_amp [right]:inclusive_or_expression_no_name {-> New expression_no_name.cand(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {amp_name} [left]:conditional_and_expression_no_name amp_amp [right]:name {-> New expression_no_name.cand(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_amp} [left]:name amp_amp [right]:inclusive_or_expression_no_name {-> New expression_no_name.cand(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_amp_name} [left]:name amp_amp [right]:name {-> New expression_no_name.cand(New expression.name(left.name), New expression.name(right.name))};

  // 15.24

  //conditional_or_expression =
  //  {and} conditional_and_expression |
  //  {bar} conditional_or_expression bar_bar conditional_and_expression;

  conditional_or_expression_no_name {-> expression_no_name} =
    {and} conditional_and_expression_no_name {-> conditional_and_expression_no_name.expression_no_name} |
    {bar} [left]:conditional_or_expression_no_name bar_bar [right]:conditional_and_expression_no_name {-> New expression_no_name.cor(New expression.expression(left.expression_no_name), New expression.expression(right.expression_no_name))} |
    {bar_name} [left]:conditional_or_expression_no_name bar_bar [right]:name {-> New expression_no_name.cor(New expression.expression(left.expression_no_name), New expression.name(right.name))} |
    {name_bar} [left]:name bar_bar [right]:conditional_and_expression_no_name {-> New expression_no_name.cor(New expression.name(left.name), New expression.expression(right.expression_no_name))} |
    {name_bar_name} [left]:name bar_bar [right]:name {-> New expression_no_name.cor(New expression.name(left.name), New expression.name(right.name))};

  // 15.25

  //conditional_expression =
  //  {or} conditional_or_expression |
  //  {qmark} conditional_or_expression qmark expression colon conditional_expression;

  conditional_expression_no_name {-> expression_no_name} =
    {or} conditional_or_expression_no_name {-> conditional_or_expression_no_name.expression_no_name} |
    {qmark_colon} [cond]:conditional_or_expression_no_name qmark [true]:expression_no_name colon [false]:conditional_expression_no_name {-> New expression_no_name.qmark(New expression.expression(cond.expression_no_name), New expression.expression(true.expression_no_name), New expression.expression(false.expression_no_name))} |
    {qmark_name_colon} [cond]:conditional_or_expression_no_name qmark [true]:name colon [false]:conditional_expression_no_name {-> New expression_no_name.qmark(New expression.expression(cond.expression_no_name), New expression.name(true.name), New expression.expression(false.expression_no_name))} |
    {qmark_colon_name} [cond]:conditional_or_expression_no_name qmark [true]:expression_no_name colon [false]:name {-> New expression_no_name.qmark(New expression.expression(cond.expression_no_name), New expression.expression(true.expression_no_name), New expression.name(false.name))} |
    {qmark_name_colon_name} [cond]:conditional_or_expression_no_name qmark [true]:name colon [false]:name {-> New expression_no_name.qmark(New expression.expression(cond.expression_no_name), New expression.name(true.name), New expression.name(false.name))} |
    {name_qmark_colon} [cond]:name qmark [true]:expression_no_name colon [false]:conditional_expression_no_name {-> New expression_no_name.qmark(New expression.name(cond.name), New expression.expression(true.expression_no_name), New expression.expression(false.expression_no_name))} |
    {name_qmark_name_colon} [cond]:name qmark [true]:name colon [false]:conditional_expression_no_name {-> New expression_no_name.qmark(New expression.name(cond.name), New expression.name(true.name), New expression.expression(false.expression_no_name))} |
    {name_qmark_colon_name} [cond]:name qmark [true]:expression_no_name colon [false]:name {-> New expression_no_name.qmark(New expression.name(cond.name), New expression.expression(true.expression_no_name), New expression.name(false.name))} |
    {name_qmark_name_colon_name} [cond]:name qmark [true]:name colon [false]:name {-> New expression_no_name.qmark(New expression.name(cond.name), New expression.name(true.name), New expression.name(false.name))};

  // 15.26

  //assignment_expression =
  //  {expression} conditional_expression |
  //  {assignment} assignment;

  assignment_expression_no_name {-> expression_no_name} =
    {expression} conditional_expression_no_name {-> conditional_expression_no_name.expression_no_name} |
    {assignment} assignment {-> assignment.expression_no_name};

  //assignment =
  //  left_hand_side assignment_operator assignment_expression;

  assignment {-> expression_no_name} =
    {assignment} left_hand_side assignment_operator assignment_expression_no_name {-> New expression_no_name.assignment(left_hand_side, assignment_operator, New expression.expression(assignment_expression_no_name.expression_no_name))} |
    {name} left_hand_side assignment_operator name {-> New expression_no_name.assignment(left_hand_side, assignment_operator, New expression.name(name.name))};

  left_hand_side =
    {expression} name |
    {field} field_access |
    {array} array_access;

  assignment_operator =
    {assign} assign |
    {star_assign} star_assign |
    {slash_assign} slash_assign |
    {percent_assign} percent_assign |
    {plus_assign} plus_assign |
    {minus_assign} minus_assign |
    {shl_assign} shl_assign |
    {shr_assign} shr_assign |
    {ushr_assign} ushr_assign |
    {amp_assign} amp_assign |
    {caret_assign} caret_assign |
    {bar_assign} bar_assign;

  // 15.27

  //expression =
  //  assignment_expression;

  expression_no_name {-> expression_no_name} =
    assignment_expression_no_name {-> assignment_expression_no_name.expression_no_name};

  // 15.28

  //constant_expression =
  //  expression;

  constant_expression_no_name =
    expression_no_name;

  // Kola Stuff

  port_declaration {-> port_declaration} = 
    modifiers? port_keyword identifier port_body {-> New port_declaration([modifiers.modifier], identifier, port_body.port_body)};

  event_declaration {-> event_declaration} =
    modifiers? event_keyword identifier type_parameters? header_fields? super? interfaces? class_body {-> New event_declaration([modifiers.modifier], identifier, [type_parameters.type_parameter], header_fields, [interfaces.interface_type], class_body.class_body)};

  component_declaration {-> component_declaration} =
    modifiers? component_keyword definition_keyword identifier type_parameters? component_body {-> New component_declaration([modifiers.modifier], identifier, [type_parameters.type_parameter], component_body.component_body)};

  port_body {-> port_body} = 
    l_brc port_body_declarations? r_brc {-> New port_body([port_body_declarations.port_body_declaration])};

  port_body_declarations {-> port_body_declaration*}= 
    {declaration} port_body_declaration {-> [port_body_declaration]}|
    {declarations} port_body_declarations port_body_declaration {-> [port_body_declarations.port_body_declaration, port_body_declaration]};

  port_body_declaration = 
    {indication} indications_declaration |
    {request} requests_declaration;

  indications_declaration {-> indications_declaration}=
    indication_keyword l_brc indication_declarations r_brc {-> New indications_declaration([indication_declarations.class_type])};

  indication_declarations {-> class_type*}= 
    {declaration} indication_declaration {-> [indication_declaration.class_type]}|
    {declarations} indication_declarations comma indication_declaration {-> [indication_declarations.class_type, indication_declaration.class_type]};

  indication_declaration {-> class_type} = 
    class_type {-> class_type};

  requests_declaration {-> requests_declaration}=
    request_keyword l_brc request_declarations r_brc {-> New requests_declaration([request_declarations.class_type])};

  request_declarations {-> class_type*} = 
    {declaration} request_declaration {-> [request_declaration.class_type]}|
    {declarations} request_declarations comma request_declaration {-> [request_declarations.class_type, request_declaration.class_type]};

  request_declaration {-> class_type} = 
    class_type {-> class_type};

  header_fields {-> header_fields} = 
    l_par formal_parameter_list? r_par {-> New header_fields(formal_parameter_list)};

  component_body {-> component_body}= 
    l_brc component_body_declarations? r_brc {-> New component_body([component_body_declarations.component_body_declaration])};

  component_body_declarations {-> component_body_declaration*} = 
    {declaration} component_body_declaration {-> [component_body_declaration]}|
    {declarations} component_body_declarations component_body_declaration {-> [component_body_declarations.component_body_declaration, component_body_declaration]};

  component_body_declaration = 
    {member} class_member_declaration |
    {instance} instance_initializer |
    {static} static_initializer |
    {constuctor} constructor_declaration |
    {init} init_declaration |
    {port} port_field_declaration |
    {component} child_declaration |
    {handling} handling_declaration;

  handling_declaration = 
    {handle} handle_declaration |
    {handler} handler_declaration |
    {connect} connect_statement |
    {subscribe} subscribe_statement |
    {disconnect} disconnect_statement |
    {unsubscribe} unsubscribe_statement;

  init_declaration {-> init_declaration} = 
    modifiers? init_keyword header_fields? constructor_body {-> New init_declaration([modifiers.modifier], header_fields, constructor_body)};

  port_field_declaration {-> port_field_declaration} = 
    {requires} requires_port {-> New port_field_declaration.requires(requires_port.class_type, requires_port.identifier)}|
    {provides} provides_port {-> New port_field_declaration.provides(provides_port.class_type, provides_port.identifier)};

  requires_port {-> class_type identifier} = 
    requires_keyword class_type identifier semi {-> class_type identifier};

  provides_port {-> class_type identifier} = 
    provides_keyword class_type identifier semi {-> class_type identifier};

  child_declaration {-> child_declaration} = 
    component_keyword class_type component_initialization? identifier semi {-> New child_declaration(class_type, component_initialization, identifier)};

  component_initialization {-> component_initialization} = 
    l_par argument_list? r_par {-> New component_initialization([argument_list.argument])};

  handle_declaration {-> handle_declaration} = 
    handle_keyword [handler_id]:identifier r_arrow [port_id]:identifier colon class_type [event_id]:identifier block {-> New handle_declaration(handler_id, port_id, class_type, event_id, block)};

  handler_declaration {-> handler_declaration} =
    handler_keyword [handler_id]:identifier colon class_type [event_id]:identifier block{-> New handler_declaration(handler_id, class_type, event_id, block)};

  connect_statement {-> connect_statement} =
    connect_keyword [provided_id]:identifier r_arrow [required_id]:identifier colon class_type semi {-> New connect_statement(provided_id, required_id, class_type)};

  subscribe_statement {-> subscribe_statement} = 
    subscribe_keyword [handler_id]:identifier r_arrow [port_id]:identifier semi {-> New subscribe_statement(handler_id, port_id)};

  disconnect_statement {-> disconnect_statement} = 
    disconnect_keyword [provided_id]:identifier r_arrow [required_id]:identifier colon class_type semi {-> New disconnect_statement(provided_id, required_id, class_type)};

  unsubscribe_statement {-> unsubscribe_statement} = 
    unsubscribe_keyword [handler_id]:identifier r_arrow [port_id]:identifier semi {-> New unsubscribe_statement(handler_id, port_id)};

  trigger_statement {-> trigger_statement} =
    {name} trigger_keyword name r_arrow identifier semi {-> New trigger_statement(New expression.name(name.name), identifier)} |
    {expression} trigger_keyword expression_no_name r_arrow identifier semi {-> New trigger_statement(New expression.expression(expression_no_name.expression_no_name), identifier)};


//////////////////////////////////////////
//////////////// AST ////////////////////
/////////////////////////////////////////


Abstract Syntax Tree

java_compilation_unit = compilation_unit;

compilation_unit = package_declaration? import_declaration* type_declaration*;

package_declaration = modifier* name;

import_declaration = 
    {single} name |
    {type} name |
    {static} name |
    {demand} name;

type_declaration =
    {class} class_declaration |
    {interface} interface_declaration |
    {port} port_declaration |
    {event} event_declaration |
    {component} component_declaration |
    {semi} semi;

modifier =
    {annotation} annotation |
    {public} public_keyword |
    {protected} protected_keyword |
    {private} private_keyword |
    {abstract} abstract_keyword |
    {static} static_keyword |
    {final} final_keyword |
    {strictfp} strictfp_keyword |
    {transient} transient_keyword |
    {volatile} volatile_keyword |
    {synchronized} synchronized_keyword |
    {native} native_keyword;

name = identifier*;

class_declaration = 
  {class} normal_class_declaration |
  {enum} enum_declaration;

interface_declaration =
    {interface} normal_interface_declaration |
    {annotation} annotation_type_declaration;

annotation =
    {normal_annotation} normal_annotation |
    {marker_annotation} marker_annotation |
    {single} single_element_annotation;

normal_annotation = name element_value_pair*;

element_value_pair = identifier element_value;

element_value =
    {conditional} expression |
    {annotation} annotation |
    {array} element_value_array_initializer;

element_value_array_initializer = element_value*;

marker_annotation = identifier;

single_element_annotation = identifier element_value;

normal_class_declaration = modifier* identifier type_parameter* [parent]:class_type? interface_type* class_body;

enum_declaration = modifier* identifier interface_type* enum_body;

normal_interface_declaration = modifier* identifier type_parameter* [extends_interfaces]:interface_type* interface_body;

annotation_type_declaration = modifier* identifier annotation_type_body;

type_parameter = identifier type_bound?;

type_bound = interface_type+;

// Kola

port_declaration = 
    modifier* identifier port_body;

event_declaration =
    modifier* identifier type_parameter* header_fields? interface_type* class_body;

header_fields = formal_parameter_list?;

component_declaration =
    modifier* identifier type_parameter* component_body;

port_body = port_body_declaration*;

port_body_declaration = 
    {indication} indications_declaration |
    {request} requests_declaration;

indications_declaration = class_type*;

requests_declaration = class_type*;

component_body = component_body_declaration*;

component_body_declaration = 
    {member} class_member_declaration |
    {instance} instance_initializer |
    {static} static_initializer |
    {constuctor} constructor_declaration |
    {init} init_declaration |
    {port} port_field_declaration |
    {component} child_declaration |
    {handling} handling_declaration;

handling_declaration = 
    {handle} handle_declaration |
    {handler} handler_declaration |
    {connect} connect_statement |
    {subscribe} subscribe_statement |
    {disconnect} disconnect_statement |
    {unsubscribe} unsubscribe_statement;

init_declaration = modifier* header_fields? constructor_body;

port_field_declaration = 
    {requires} class_type identifier |
    {provides} class_type identifier;

child_declaration = 
    class_type component_initialization? identifier;

component_initialization = argument*;

handle_declaration = [handler_id]:identifier [port_id]:identifier class_type [event_id]:identifier block;

handler_declaration =[handler_id]:identifier class_type [event_id]:identifier block;


// - Kola

literal =
    {integer} integer_literal |
    {floating_point} floating_point_literal |
    {boolean} boolean_literal |
    {character} character_literal |
    {string} string_literal |
    {null} null_literal;

class_type = type_decl_specifier type_arguments?;

interface_type = type_decl_specifier type_arguments?;

class_or_interface_type_no_arguments = name;

class_or_interface_type = type_decl_specifier type_arguments?;

type_decl_specifier = name args_with_name*;

args_with_name = type_arguments name;

class_name = name;

type_arguments = 
    {gt} type_argument+ |
    {shr} [ta1s]:type_argument* type_decl_specifier [ta2s]:type_argument+ |
    {ushr} [ta1s]:type_argument* [specifier1]:type_decl_specifier [ta2s]:type_argument* [specifier2]:type_decl_specifier [ta3s]:type_argument+;

type_argument = 
    {reference} reference_type |
    {wildcard} wildcard;

wildcard = wildcard_bounds?;

wildcard_bounds =
    {extends} reference_type |
    {super} reference_type;

primitive_type =
    {numeric} numeric_type |
    {boolean} boolean_keyword;

  numeric_type =
    {integral} integral_type |
    {floating} floating_point_type;

  integral_type =
    {byte} byte_keyword |
    {short} short_keyword |
    {int} int_keyword |
    {long} long_keyword |
    {char} char_keyword;

  floating_point_type =
    {float} float_keyword |
    {double} double_keyword;

reference_type =
    {class} class_or_interface_type |
    {array} array_type;

reference_type_no_arguments =
    {class} class_or_interface_type_no_arguments |
    {array} array_type_no_arguments;

array_type =
    {class} class_or_interface_type dim+ |
    {primitive} primitive_type dim+;

array_type_no_arguments =
    {class} class_or_interface_type_no_arguments dim+ |
    {primitive} primitive_type dim+;

type =
    {primitive} primitive_type |
    {reference} reference_type;

type_no_arguments =
    {primitive} primitive_type |
    {reference} reference_type_no_arguments;

class_body = class_body_declaration*;

class_body_declaration =
    {member} class_member_declaration |
    {instance} instance_initializer |
    {static} static_initializer |
    {constructor} constructor_declaration;

enum_body = enum_constant* class_body_declaration*;

enum_constant = modifier* identifier argument* class_body?;

interface_body = interface_member_declaration*;

interface_member_declaration =
    {constant} constant_declaration |
    {method} abstract_method_declaration |
    {class} class_declaration |
    {interface} interface_declaration |
    {semi} semi;

class_member_declaration =
    {field} field_declaration |
    {method} method_declaration |
    {class} class_declaration |
    {interface} interface_declaration |
    {semi} semi;

constant_declaration = modifier* type variable_declarator+;

variable_declarator =
    {id} variable_declarator_id |
    {initializer} variable_declarator_id variable_initializer;

variable_declarator_id = identifier dim*;

variable_initializer =
    {expression} expression |
    {initializer} array_initializer;

abstract_method_declaration =
    modifier* type_parameter* result method_declarator throws?;

field_declaration = modifier* type variable_declarator+;

method_declaration = method_header method_body;

method_header = modifier* type_parameter* result method_declarator throws?;

method_declarator = identifier formal_parameter_list? dim*;

annotation_type_body = annotation_type_element_declaration*;

annotation_type_element_declaration =
    {abstract} modifier* type identifier [default_value]:element_value? |
    {constant} constant_declaration |
    {class} class_declaration |
    {interface} interface_declaration |
    {semi} semi;

instance_initializer = block;

static_initializer = block;

array_initializer = variable_initializer*;

constructor_declaration = modifier* constructor_declarator throws? constructor_body;

constructor_declarator =
    type_parameter* simple_type_name formal_parameter_list?;

simple_type_name = identifier;

formal_parameter_list =
    {parameter} last_formal_parameter |
    {parameters} formal_parameter* last_formal_parameter;

last_formal_parameter =
    {variable} formal_parameter |
    {formal} formal_parameter;

formal_parameter = modifier* type variable_declarator_id;

argument =
    {expression} expression_no_name |
    {name} name;

result =
    {type} type |
    {void} void_keyword;

throws = exception_type+;

exception_type =
    name;

method_body =
    {block} block |
    {semi} semi;

block = block_statement*;

block_statement =
    {variable} local_variable_declaration |
    {class} class_declaration |
    {statement} statement;

statement =
    {without_trailing_substatement} statement_without_trailing_substatement |
    {labeled_statement} labeled_statement |
    {if} if_then_statement |
    {if_else} if_then_else_statement |
    {while_statement} while_statement |
    {for_statement} for_statement;

statement_without_trailing_substatement =
    {block} block |
    {empty_statement} |
    {expression_statement} statement_expression |
    {assert_statement} assert_statement |
    {switch_statement} switch_statement |
    {do_statement} do_statement |
    {break_statement} break_statement |
    {continue_statement} continue_statement |
    {return_statement} return_statement |
    {synchronized_statement} synchronized_statement |
    {throw_statement} throw_statement |
    {try_statement} try_statement |
    {connect} connect_statement |
    {disconnect} disconnect_statement |
    {subscribe} subscribe_statement |
    {unsubscribe} unsubscribe_statement |
    {trigger} trigger_statement;

statement_no_short_if =
    {without_trailing_substatement} statement_without_trailing_substatement |
    {labeled_statement} labeled_statement_no_short_if |
    {if} if_then_else_statement_no_short_if |
    {while_statement} while_statement_no_short_if |
    {for_statement} for_statement_no_short_if;

labeled_statement = identifier statement;

labeled_statement_no_short_if = identifier statement_no_short_if;

local_variable_declaration =
    modifier* type variable_declarator+;

//expression_statement = statement_expression;

statement_expression = expression_no_name;

if_then_statement = [cond]:expression [then]:statement;

if_then_else_statement = [cond]:expression [then]:statement_no_short_if [else]:statement;

if_then_else_statement_no_short_if = [cond]:expression [then]:statement_no_short_if [else]:statement_no_short_if;


while_statement = [cond]:expression [do]:statement;

while_statement_no_short_if = [cond]:expression [do]:statement_no_short_if;

for_statement =
    {basic_for} basic_for_statement |
    {enhanced_for} enhanced_for_statement;

basic_for_statement = 
    {expression} [init]:for_init? [cond]:expression_no_name? [update]:for_update? [do]:statement |
    {name} [init]:for_init? [cond]:name? [update]:for_update? [do]:statement;

for_statement_no_short_if =
    {expression} [init]:for_init? [cond]:expression_no_name? [update]:for_update? [do]:statement_no_short_if |
    {name} [init]:for_init? [cond]:name [update]:for_update? [do]:statement_no_short_if;

for_init =
    {statement} expression_no_name+ |
    {local} local_variable_declaration;

for_update = expression_no_name+;

enhanced_for_statement = [variable]:formal_parameter [iterable]:expression [do]:statement;

assert_statement =
    {simple} [cond]:expression |
    {details} [cond]:expression [msg]:expression;

switch_statement = [target]:expression switch_block;

switch_block = switch_block_statement_group* switch_label*;

switch_block_statement_group =
    switch_label+ block_statement+;

switch_label =
    {constant} [case]:constant_expression_no_name |
    {constant_name} [case]:name |
    {default} default_keyword;

do_statement = [do]:statement [cond]:expression;

break_statement = identifier?;

continue_statement = identifier?;

return_statement =
    {expression} [return_value]:expression |
    {void} ;

synchronized_statement = [lock]:expression block;

throw_statement = [throwable]:expression;

try_statement =
    {catch} block catch_clause+ |
    {finally} block catch_clause* finally |
    {resources} try_with_resources_statement;

catch_clause = catch_formal_parameter block;

catch_formal_parameter = modifier* [catch_types]:class_type+ variable_declarator_id;

finally = block;

try_with_resources_statement = resource_specification block variable_declarator_id catch_clause* finally?;

resource_specification = resource+;

resource = modifier* type variable_declarator_id expression;

connect_statement = [provided_id]:identifier [required_id]:identifier class_type;

subscribe_statement = [handler_id]:identifier [port_id]:identifier;

disconnect_statement = [provided_id]:identifier [required_id]:identifier class_type;

unsubscribe_statement = [handler_id]:identifier [port_id]:identifier;

trigger_statement = [event]:expression [port_id]:identifier;

left_hand_side =
    {expression} name |
    {field} field_access |
    {array} array_access;

assignment_operator =
    {assign} assign |
    {star_assign} star_assign |
    {slash_assign} slash_assign |
    {percent_assign} percent_assign |
    {plus_assign} plus_assign |
    {minus_assign} minus_assign |
    {shl_assign} shl_assign |
    {shr_assign} shr_assign |
    {ushr_assign} ushr_assign |
    {amp_assign} amp_assign |
    {caret_assign} caret_assign |
    {bar_assign} bar_assign;

constructor_body = explicit_constructor_invocation? block_statement*;

explicit_constructor_invocation =
    {this} [non_wild_type_arguments]:reference_type* argument* |
    {super} [non_wild_type_arguments]:reference_type* argument* |
    {primary} expression_no_name [non_wild_type_arguments]:reference_type* argument*;

expression = 
    {name} name |
    {expression} expression_no_name;

expression_no_name = 
    {assignment} left_hand_side assignment_operator expression |
    {qmark} [cond]:expression [true]:expression [false]:expression |
    {cor} [left]:expression [right]:expression |
    {cand} [left]:expression [right]:expression |
    {ior} [left]:expression [right]:expression |
    {eor} [left]:expression [right]:expression |
    {and} [left]:expression [right]:expression |
    {eq} [left]:expression [right]:expression |
    {neq} [left]:expression [right]:expression |
    {instanceof} [left]:expression [right]:reference_type |
    {lt} [left]:expression [right]:expression |
    {gt} [left]:expression [right]:expression |
    {lteq} [left]:expression [right]:expression |
    {gteq} [left]:expression [right]:expression |
    {shl} [left]:expression [right]:expression |
    {shr} [left]:expression [right]:expression |
    {ushr} [left]:expression [right]:expression |
    {plus} [left]:expression [right]:expression |
    {minus} [left]:expression [right]:expression |
    {mul} [left]:expression [right]:expression |
    {div} [left]:expression [right]:expression |
    {mod} [left]:expression [right]:expression |
    {pre_inc} expression |
    {pre_decr} expression |
    {uplus} expression |
    {uminus} expression |
    {tilde} expression |
    {emark} expression |
    {pcast} [target]:primitive_type expression |
    {rcast} [target]:reference_type expression |
    {post_inc} expression |
    {post_decr} expression |
    {literal} literal |
    {type} type_no_arguments |
    {void} |
    {this} |
    {class} class_name |
    {field} field_access |
    {method} method_invocation |
    {array} array_access |
    {array_creation} array_creation_expression |
    {instance} class_instance_creation_expression |
    {expression} expression;


constant_expression_no_name = expression_no_name;

method_invocation =
    {method} name argument* |
    {primary} expression_no_name [non_wild_type_arguments]:reference_type* identifier argument* |
    {super} [non_wild_type_arguments]:reference_type* identifier argument* |
    {class} class_name [non_wild_type_arguments]:reference_type* identifier argument* |
    {type} name [non_wild_type_arguments]:reference_type* identifier argument*;

class_instance_creation_expression =
    {new} type_arguments? type_decl_specifier type_arguments_or_diamond? argument* class_body? |
    {primary} expression_no_name type_arguments? identifier type_arguments_or_diamond? argument* class_body?;

type_arguments_or_diamond =
    {type_arguments} type_arguments |
    {diamond} ;

field_access =
    {primary} expression_no_name identifier |
    {super} identifier |
    {class} class_name identifier;

array_access = [array]:expression [field]:expression;

array_creation_expression =
    {primitive} primitive_type dim_expr+ dim* |
    {class} class_or_interface_type dim_expr+ dim* |
    {primitive_initializer} primitive_type dim+ array_initializer |
    {class_initializer} class_or_interface_type dim+ array_initializer;

dim_expr = expression;

dim = ;




